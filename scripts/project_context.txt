=== PROJECT STRUCTURE ===
crypto_bot/
    .gitignore
    config.py
    main.py
    questions.json
    Readme.txt
    requirements.txt
    scripts/
        export_context.py
    services/
        email_service.py
        market_data_service.py
        qa_service.py
        report_service.py
        trading_service.py
    utils/
        data_loader.py
        executor.py
        trade_logger.py

==================================================

=== FILE CONTENTS ===

--- START OF FILE: config.py ---
# config.py
from gitIgnoreFile.MyKey import myApiKey, mySecretKey
from gitIgnoreFile.MyMail import EmailSender, EmailPassword, EmailReceiver
from gitIgnoreFile.MyGeminiKey import MyGeminiApiKey, MyGeminiAiName

# --- BingX API è¨­å®š ---
API_KEY = myApiKey
SECRET_KEY = mySecretKey

# --- äº¤æ˜“æ¨™çš„èˆ‡è³‡é‡‘ç®¡ç† ---
COIN_LIST = [
    "BTC-USDT",
    "ETH-USDT"
]

DRY_RUN = True  # True: æ¨¡æ“¬äº¤æ˜“ | False: çœŸå¯¦ä¸‹å–®
LEVERAGE = 5
TRADING_FEE_RATE = 0.0005

# é è¨­ä¸‹å–®æ•¸é‡ (ç•¶æ‰¾ä¸åˆ° ORDER_SIZES æ™‚ä½¿ç”¨)
ORDER_AMOUNT = 0.001 

# å€‹åˆ¥å¹£ç¨®ä¸‹å–®é‡ (å»ºè­°ç´„ 10~100 USDT)
ORDER_SIZES = {
    "BTC-USDT": 0.001,   # ç´„ 90 U
    "ETH-USDT": 0.01,    # ç´„ 25 U
    "SOL-USDT": 0.5,     # ç´„ 50 U
    "DOGE-USDT": 100,    # ç´„ 30 U
    "BNB-USDT": 0.1      # ç´„ 60 U
}

# --- ç­–ç•¥èˆ‡æŒ‡æ¨™åƒæ•¸ ---
TRADE_TIMEFRAME = '15m'  # äº¤æ˜“ç”¨ K ç·š
SMA_SHORT = 7
SMA_LONG = 25

# é¢¨æ§ (0.02 = 2%)
STOP_LOSS_PCT = 0.02      
TAKE_PROFIT_PCT = 0.04    

# --- ç³»çµ±æœå‹™è¨­å®š ---
# 1. Email (SMTP)
ENABLE_EMAIL = True
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
SMTP_USERNAME = EmailSender
SMTP_PASSWORD = EmailPassword
SMTP_TO_EMAIL = EmailReceiver

# 2. Gemini AI
GEMINI_API_KEY = MyGeminiApiKey
GEMINI_MODEL_NAME = MyGeminiAiName

# 3. å ±å‘Šèˆ‡ QA
ENABLE_QA_SYSTEM = True
ENABLE_PERIODIC_REPORT = True
REPORT_INTERVAL_MINUTES = 60
QA_CHECK_INTERVAL = 5
--- END OF FILE: config.py ---

--- START OF FILE: main.py ---
import time
from datetime import datetime, timedelta
import config

# å¼•å…¥æœå‹™æ¨¡çµ„
from services.trading_service import TradingService
from services.report_service import ReportService
from services.qa_service import QAService
from services.email_service import EmailService
from services.market_data_service import MarketDataService

def main():
    print(f"ğŸ¤– Crypto Bot æ¶æ§‹é‡æ§‹ç‰ˆå•Ÿå‹•...")

    # 1. åˆå§‹åŒ–æœå‹™ (æŒ‡æ®å®˜çµ„è£å·¥å…·)
    mailer = EmailService()           
    reporter = ReportService()        
    market_data = MarketDataService() 
    qa_service = QAService("questions.json")
    
    # å°‡ reporter å’Œ mailer æ³¨å…¥çµ¦ trader (å¦‚æœæœªä¾†éœ€è¦)
    trader = TradingService(report_service=reporter, email_service=mailer) 

    # 2. è¨­å®šæ™‚é–“é–
    timers = {
        'trade': datetime.now(),         # é¦¬ä¸ŠåŸ·è¡Œä¸€æ¬¡
        'report': datetime.now(),        # é¦¬ä¸ŠåŸ·è¡Œä¸€æ¬¡
        'qa': datetime.now()             # é¦¬ä¸ŠåŸ·è¡Œä¸€æ¬¡
    }

    print("ğŸš€ ç³»çµ±é€²å…¥æ¥µé€Ÿç›£è½æ¨¡å¼...")

    while True:
        try:
            now = datetime.now()

            # --- ä»»å‹™ 1: QA å•ç­” (å„ªå…ˆç´šæœ€é«˜ï¼Œæ¯ 5 ç§’) ---
            if config.ENABLE_QA_SYSTEM and now >= timers['qa']:
                # å°‡ reporter å’Œ mailer "æ³¨å…¥" çµ¦ qa_service
                qa_service.process_pending_questions(ai_reporter=reporter, mailer=mailer)
                timers['qa'] = now + timedelta(seconds=5)

            # --- ä»»å‹™ 2: äº¤æ˜“ (æ¯ 15 åˆ†é˜) ---
            if now >= timers['trade']:
                print(f"ğŸ’° åŸ·è¡Œäº¤æ˜“ç­–ç•¥æª¢æŸ¥... {now.strftime('%H:%M')}")
                trader.run_cycle() 
                timers['trade'] = now + timedelta(minutes=15)

            # --- ä»»å‹™ 3: å®šæœŸå ±å‘Š (æ¯ 60 åˆ†é˜) ---
            if config.ENABLE_PERIODIC_REPORT and now >= timers['report']:
                print(f"ğŸ“Š åŸ·è¡Œå®šæœŸå¸‚å ´å ±å‘Š... {now.strftime('%H:%M')}")
                
                # ç¯„ä¾‹é‚è¼¯ (ä½ å¯ä»¥ä¹‹å¾Œå†è§£é™¤è¨»è§£ä¸¦ä¿®æ”¹)
                # target_symbol = "ETHUSDT"
                # df = get_klines(target_symbol) # éœ€è‡ªè¡Œå¯¦ä½œç²å–è³‡æ–™
                # if not df.empty:
                #     context = market_data.analyze_technicals(df)
                #     context['symbol'] = target_symbol
                #     html = reporter.generate_market_report(context)
                #     mailer.send_report(f"ğŸ“… å¸‚å ´é€±å ±: {target_symbol}", html)
                
                timers['report'] = now + timedelta(minutes=config.REPORT_INTERVAL_MINUTES)

            # æ¥µé€Ÿè¿´åœˆä¼‘æ¯
            time.sleep(3)

        # ğŸ”¥ é‡é»åœ¨é€™è£¡ï¼štry å€å¡ŠçµæŸå¾Œï¼Œä¸€å®šè¦æ¥ except
        except KeyboardInterrupt:
            print("\nğŸ›‘ ç¨‹å¼æ‰‹å‹•åœæ­¢")
            break
        except Exception as e:
            print(f"âŒ ä¸»è¿´åœˆç™¼ç”ŸéŒ¯èª¤: {e}")
            time.sleep(10)

if __name__ == "__main__":
    main()
--- END OF FILE: main.py ---

--- START OF FILE: questions.json ---
[
    {
        "id": "question001",
        "question": "è«‹å¹«æˆ‘èªªæ˜ä»€éº¼æ˜¯ RSI KDJ WR MACD",
        "answered": true,
        "answered_at": "2025-12-18 22:31:22"
    },
    {
        "id": "question002",
        "question": "è«‹å¹«æˆ‘èªªæ˜å¦‚ä½•è§€å¯ŸRSI KDJ WR MACD å¯ä»¥çŸ¥é“å‡çªç ´ é‚„æ˜¯å¤šé ­å›æ¡",
        "answered": true,
        "answered_at": "2025-12-18 22:33:54"
    },
    {
        "id": "question003",
        "question": "è«‹å¹«æˆ‘åˆ†æ72å°æ™‚çš„ETH 15åˆ†K ",
        "answered": true,
        "answered_at": "2025-12-18 22:46:24"
    },
    {
        "id": "question004",
        "question": "è«‹å¹«æˆ‘åˆ†æ72å°æ™‚çš„BTC 15åˆ†K",
        "answered": true,
        "answered_at": "2025-12-18 22:18:35"
    },
    {
        "id": "question005",
        "question": "æˆ‘ç›®å‰æ˜¯å¹¼æ•™è€å¸«éœ€è¦ä½ å¹«æˆ‘è¦åŠƒè½‰æˆUIUX å·¥ç¨‹å¸«",
        "answered": true,
        "answered_at": "2025-12-18 22:24:08"
    }
]
--- END OF FILE: questions.json ---

--- START OF FILE: Readme.txt ---
=== PROJECT STRUCTURE ===
crypto_bot/
    .gitignore                  => è¨­å®š Git ç‰ˆæœ¬æ§åˆ¶æ‡‰å¿½ç•¥çš„æª”æ¡ˆèˆ‡è³‡æ–™å¤¾ (å¦‚æ•æ„Ÿé‡‘é‘°ã€è™›æ“¬ç’°å¢ƒ)
    config.py                   => é›†ä¸­ç®¡ç† API é‡‘é‘°ã€ç­–ç•¥åƒæ•¸ã€é¢¨éšªæ§åˆ¶èˆ‡ç³»çµ±è¨­å®š
    main.py                     => ç¨‹å¼å…¥å£é»ï¼Œè² è²¬çµ„è£æœå‹™ã€å•Ÿå‹•è¿´åœˆèˆ‡æ’ç¨‹ç®¡ç†
    questions.json              => å„²å­˜ä½¿ç”¨è€…æå•å…§å®¹èˆ‡å›ç­”ç‹€æ…‹çš„è³‡æ–™æª”
    Readme.txt                  => å°ˆæ¡ˆæ¶æ§‹èªªæ˜èˆ‡é–‹ç™¼æ–‡ä»¶
    requirements.txt            => åˆ—å‡ºå°ˆæ¡ˆåŸ·è¡Œæ‰€éœ€çš„ Python å¥—ä»¶æ¸…å–®

    scripts/
        export_context.py       => é–‹ç™¼è¼”åŠ©å·¥å…·ï¼Œå°‡å°ˆæ¡ˆç¨‹å¼ç¢¼åŒ¯å‡ºç‚ºå–®ä¸€æ–‡å­—æª”ä»¥ä¾¿ AI Review

    services/
        email_service.py        => å°è£ SMTP å”å®šï¼Œè² è²¬ç™¼é€ HTML æ ¼å¼çš„éƒµä»¶é€šçŸ¥
        market_data_service.py  => è² è²¬è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ (RSI, MA) ä¸¦ç”Ÿæˆå¸‚å ´åˆ†ææ‘˜è¦
        qa_service.py           => ç®¡ç†å•ç­”æµç¨‹ï¼Œå”èª¿ AI å›ç­”å•é¡Œä¸¦æ›´æ–°è™•ç†ç‹€æ…‹
        report_service.py       => è² è²¬ Prompt Engineeringï¼Œå‘¼å« AI ç”Ÿæˆ HTML åˆ†æå ±å‘Š
        trading_service.py      => æ ¸å¿ƒäº¤æ˜“å¤§è…¦ï¼Œæ•´åˆæ•¸æ“šåˆ†æã€ç­–ç•¥åˆ¤æ–·èˆ‡è§¸ç™¼ä¸‹å–®

    utils/
        data_loader.py          => é€é CCXT å¥—ä»¶å¾äº¤æ˜“æ‰€ç²å– K ç·šæ•¸æ“š (OHLCV)
        executor.py             => è² è²¬åŸ·è¡ŒçœŸå¯¦ä¸‹å–®ã€æ¨¡æ“¬äº¤æ˜“èˆ‡å€‰ä½ç®¡ç†
        trade_logger.py         => å°‡æ‰€æœ‰äº¤æ˜“å‹•ä½œèˆ‡æç›Šçµæœè¨˜éŒ„è‡³ JSON æª”æ¡ˆ

==================================================
--- END OF FILE: Readme.txt ---

--- START OF FILE: requirements.txt ---
ccxt
pandas
pandas_ta
--- END OF FILE: requirements.txt ---

--- START OF FILE: scripts\export_context.py ---
import os
import fnmatch

# ğŸ”¥ 1. è·¯å¾‘è¨­å®š
# CURRENT_DIR:  .../crypto_bot/scripts (è…³æœ¬æ‰€åœ¨ä½ç½®)
# PROJECT_ROOT: .../crypto_bot (å°ˆæ¡ˆæ ¹ç›®éŒ„)
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(CURRENT_DIR)

# é è¨­å¿½ç•¥æ¸…å–®
# æ³¨æ„ï¼šæˆ‘å€‘ä¾ç„¶å¿½ç•¥ scripts è³‡æ–™å¤¾çš„æƒæï¼Œé¿å…æŠŠè…³æœ¬è‡ªå·±ä¹Ÿå¯«é€²å» context
DEFAULT_IGNORE_DIRS = {
    '.git', '.venv', 'venv', '__pycache__', 
    '.idea', '.vscode', 'node_modules', 'logs'
}

DEFAULT_IGNORE_FILES = {
    'project_context.txt', '.DS_Store', 'poetry.lock', 'package-lock.json', '*.pyc'
}

ALLOWED_EXTENSIONS = {
    '.py', '.json', '.md', '.txt', '.yml', '.yaml', 
    '.html', '.css', '.js', '.ini'
}

def load_gitignore_patterns(root_dir):
    """è®€å– .gitignore"""
    gitignore_path = os.path.join(root_dir, '.gitignore')
    patterns = set()
    
    if os.path.exists(gitignore_path):
        try:
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        patterns.add(line.rstrip('/'))
        except Exception as e:
            print(f"âš ï¸ ç„¡æ³•è®€å– .gitignore: {e}")
            
    return patterns

def is_ignored(path, root_dir, ignore_dirs, ignore_files, gitignore_patterns):
    """æª¢æŸ¥æ˜¯å¦å¿½ç•¥"""
    name = os.path.basename(path)
    
    if name in ignore_dirs or name in ignore_files:
        return True
    
    rel_path = os.path.relpath(path, root_dir)
    rel_path_unix = rel_path.replace(os.sep, '/')
    
    for pattern in gitignore_patterns:
        if fnmatch.fnmatch(name, pattern):
            return True
        if fnmatch.fnmatch(rel_path_unix, pattern):
            return True
        if pattern in rel_path_unix.split('/'):
             return True

    return False

def generate_project_context(output_filename="project_context.txt"):
    # ğŸ”¥ ä¿®æ”¹é€™è£¡ï¼šå°‡è¼¸å‡ºè·¯å¾‘æ”¹ç‚º CURRENT_DIR (scripts è³‡æ–™å¤¾)
    output_file = os.path.join(CURRENT_DIR, output_filename)
    
    gitignore_patterns = load_gitignore_patterns(PROJECT_ROOT)
    
    print(f"ğŸ“‚ æƒæç›®æ¨™: {PROJECT_ROOT}")
    print(f"ğŸ“„ è¼¸å‡ºä½ç½®: {output_file}")

    with open(output_file, 'w', encoding='utf-8') as outfile:
        # 1. ç›®éŒ„çµæ§‹
        outfile.write("=== PROJECT STRUCTURE ===\n")
        for dirpath, dirnames, filenames in os.walk(PROJECT_ROOT):
            dirnames[:] = [d for d in dirnames if not is_ignored(os.path.join(dirpath, d), PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns)]
            
            level = dirpath.replace(PROJECT_ROOT, '').count(os.sep)
            indent = ' ' * 4 * level
            outfile.write(f"{indent}{os.path.basename(dirpath)}/\n")
            
            subindent = ' ' * 4 * (level + 1)
            for f in filenames:
                if not is_ignored(os.path.join(dirpath, f), PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns):
                    outfile.write(f"{subindent}{f}\n")
        
        outfile.write("\n" + "="*50 + "\n\n")

        # 2. æª”æ¡ˆå…§å®¹
        outfile.write("=== FILE CONTENTS ===\n")
        file_count = 0
        for dirpath, dirnames, filenames in os.walk(PROJECT_ROOT):
            dirnames[:] = [d for d in dirnames if not is_ignored(os.path.join(dirpath, d), PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns)]
            
            for filename in filenames:
                filepath = os.path.join(dirpath, filename)
                
                if is_ignored(filepath, PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns):
                    continue
                
                ext = os.path.splitext(filename)[1]
                if ext not in ALLOWED_EXTENSIONS and filename != 'requirements.txt':
                    continue

                rel_path = os.path.relpath(filepath, PROJECT_ROOT)
                
                try:
                    with open(filepath, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        
                    outfile.write(f"\n--- START OF FILE: {rel_path} ---\n")
                    outfile.write(content)
                    outfile.write(f"\n--- END OF FILE: {rel_path} ---\n")
                    file_count += 1
                except Exception as e:
                    print(f"âš ï¸ ç„¡æ³•è®€å–æª”æ¡ˆ {rel_path}: {e}")

    print(f"âœ… åŒ¯å‡ºå®Œæˆï¼æª”æ¡ˆä½æ–¼ scripts è³‡æ–™å¤¾å…§ã€‚")

if __name__ == "__main__":
    generate_project_context()
--- END OF FILE: scripts\export_context.py ---

--- START OF FILE: services\email_service.py ---
#services/email_service.py
import sys
import os

# å–å¾—ç›®å‰æª”æ¡ˆæ‰€åœ¨çš„è³‡æ–™å¤¾ (services)
current_dir = os.path.dirname(os.path.abspath(__file__))
# å–å¾—ä¸Šä¸€å±¤è³‡æ–™å¤¾ (crypto_bot æ ¹ç›®éŒ„)
parent_dir = os.path.dirname(current_dir)
# å°‡æ ¹ç›®éŒ„åŠ å…¥ Python æœå°‹è·¯å¾‘
sys.path.append(parent_dir)

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
import config

class EmailService:
    def __init__(self):
        self.smtp_server = config.SMTP_SERVER
        self.smtp_port = config.SMTP_PORT
        self.username = config.SMTP_USERNAME
        self.password = config.SMTP_PASSWORD
        self.to_addr = config.SMTP_TO_EMAIL  # é è¨­æ”¶ä»¶äºº

    def send_report(self, subject: str, html_content: str, to_email: str = None) -> bool:
        """
        ç™¼é€ HTML æ ¼å¼çš„éƒµä»¶
        :param subject: éƒµä»¶æ¨™é¡Œ
        :param html_content: HTML å…§å®¹
        :param to_email: æ”¶ä»¶äºº (è‹¥æœªæŒ‡å®šå‰‡ä½¿ç”¨ config é è¨­å€¼)
        :return: æ˜¯å¦ç™¼é€æˆåŠŸ
        """
        # å¦‚æœ config æ²’è¨­å®šé–‹å•Ÿéƒµä»¶ï¼Œç›´æ¥è·³é (æ–¹ä¾¿æ¸¬è©¦)
        if not getattr(config, 'ENABLE_EMAIL', True):
            print(f"ğŸ”• Email åŠŸèƒ½å·²é—œé–‰ï¼Œè·³éç™¼é€: {subject}")
            return True

        target_email = to_email if to_email else self.to_addr

        # å»ºç«‹éƒµä»¶ç‰©ä»¶
        msg = MIMEMultipart()
        msg['From'] = self.username
        msg['To'] = target_email
        msg['Subject'] = Header(subject, 'utf-8')

        # åŠ å…¥ HTML å…§æ–‡
        msg.attach(MIMEText(html_content, 'html', 'utf-8'))

        try:
            # å»ºç«‹ SMTP é€£ç·š
            # å¦‚æœæ˜¯ Gmail æˆ–æ˜¯ä½¿ç”¨ SSL (Port 465)
            if self.smtp_port == 465:
                server = smtplib.SMTP_SSL(self.smtp_server, self.smtp_port)
            else:
                # å¦‚æœæ˜¯ TLS (Port 587)
                server = smtplib.SMTP(self.smtp_server, self.smtp_port)
                server.starttls()

            server.login(self.username, self.password)
            server.send_message(msg)
            server.quit()
            
            print(f"ğŸ“¨ Email ç™¼é€æˆåŠŸ: {subject} -> {target_email}")
            return True

        except Exception as e:
            print(f"âŒ Email ç™¼é€å¤±æ•—: {e}")
            return False

# ç”¨æ³•æ¸¬è©¦
if __name__ == "__main__":
    email_service = EmailService()
    email_service.send_report("æ¸¬è©¦éƒµä»¶", "<h1>é€™æ˜¯æ¸¬è©¦</h1><p>ç³»çµ±é‹ä½œæ­£å¸¸ã€‚</p>")
--- END OF FILE: services\email_service.py ---

--- START OF FILE: services\market_data_service.py ---
#services/market_data_service.py
import pandas as pd
import pandas_ta as ta
from datetime import datetime
from typing import Dict, Any

class MarketDataService:
    def __init__(self):
        # é€™è£¡å¯ä»¥æ”¾ä¸€äº›å…¨åŸŸçš„æŒ‡æ¨™è¨­å®šåƒæ•¸
        self.rsi_length = 14
        self.ma_fast = 7
        self.ma_slow = 25
        self.bb_length = 20

    def analyze_technicals(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ä¸¦è¿”å›çµæ§‹åŒ–æ•¸æ“šèˆ‡æ–‡å­—æè¿°
        :param df: åŒ…å« Open, High, Low, Close çš„ DataFrame
        :return: åŒ…å«æ•¸å€¼èˆ‡æ–‡å­—æ‘˜è¦çš„å­—å…¸
        """
        if df is None or df.empty:
            print("âš ï¸ è­¦å‘Š: å‚³å…¥çš„ DataFrame ç‚ºç©º")
            return {}

        # è¤‡è£½ä¸€ä»½ä»¥å…ä¿®æ”¹åˆ°åŸå§‹è³‡æ–™
        df = df.copy()

        # 1. è¨ˆç®—æŒ‡æ¨™ (ä½¿ç”¨ pandas_ta)
        # RSI
        df['rsi'] = ta.rsi(df['close'], length=self.rsi_length)
        
        # MA (ç§»å‹•å¹³å‡)
        df['ma_fast'] = ta.sma(df['close'], length=self.ma_fast)
        df['ma_slow'] = ta.sma(df['close'], length=self.ma_slow)
        
        # Bollinger Bands (å¸ƒæ—é€šé“)
        bbands = ta.bbands(df['close'], length=self.bb_length)
        # pandas_ta çš„ bbands æ¬„ä½åç¨±é€šå¸¸æ˜¯ BBL_20_2.0, BBM_20_2.0, BBU_20_2.0
        # ç‚ºäº†æ–¹ä¾¿ï¼Œæˆ‘å€‘é‡æ–°å‘½åæˆ–ç›´æ¥å–å€¼
        df['bb_upper'] = bbands.iloc[:, 2] # ä¸Šè»Œ
        df['bb_lower'] = bbands.iloc[:, 0] # ä¸‹è»Œ

        # 2. å–å¾—æœ€æ–°ä¸€ç­†æ•¸æ“š (Latest Row)
        row = df.iloc[-1]

        # 3. é‚è¼¯åˆ¤æ–· (Rule-based Logic)
        
        # è¶¨å‹¢åˆ¤æ–·
        if row['ma_fast'] > row['ma_slow']:
            trend = "å¤šé ­æ’åˆ— (Bullish)"
            trend_signal = "LONG"
        else:
            trend = "ç©ºé ­æ’åˆ— (Bearish)"
            trend_signal = "SHORT"

        # å¸ƒæ—ä½ç½®åˆ¤æ–·
        bb_pos = "ä¸­è»¸éœ‡ç›ª"
        if row['close'] >= row['bb_upper']:
            bb_pos = "è§¸åŠä¸Šè»Œ (å£“åŠ›å€/è¶…è²·)"
        elif row['close'] <= row['bb_lower']:
            bb_pos = "è§¸åŠä¸‹è»Œ (æ”¯æ’å€/è¶…è³£)"

        # 4. ç”Ÿæˆçµ¦ AI çœ‹çš„æ‘˜è¦æ–‡å­— (Prompt Material)
        # é€™è£¡çš„æ ¼å¼è¶Šæ¸…æ¥šï¼ŒAI å¯«å‡ºä¾†çš„å ±å‘Šè¶Šç²¾æº–
        ta_text = f"""
        ã€æœ€æ–°åƒ¹æ ¼æ•¸æ“šã€‘
        - ç¾åƒ¹: {row['close']:.2f}
        
        ã€è¶¨å‹¢æŒ‡æ¨™ã€‘
        - MAç‹€æ…‹: {trend}
        - çŸ­æœŸMA({self.ma_fast}): {row['ma_fast']:.2f}
        - é•·æœŸMA({self.ma_slow}): {row['ma_slow']:.2f}
        
        ã€å‹•èƒ½èˆ‡æ³¢å‹•ã€‘
        - RSI({self.rsi_length}): {row['rsi']:.2f}
        - å¸ƒæ—å¸¶ç‹€æ…‹: {bb_pos}
          (ä¸Šè»Œ: {row['bb_upper']:.2f} / ä¸‹è»Œ: {row['bb_lower']:.2f})
        """

        # 5. è¿”å›å®Œæ•´å­—å…¸
        return {
            "close": row['close'],
            "rsi": row['rsi'],
            "ma_fast": row['ma_fast'],
            "ma_slow": row['ma_slow'],
            "bb_upper": row['bb_upper'],
            "bb_lower": row['bb_lower'],
            "trend": trend,
            "trend_signal": trend_signal, # æ–¹ä¾¿ç¨‹å¼é‚è¼¯åš if/else
            "bb_pos": bb_pos,
            "technical_analysis_text": ta_text, # é€™æ˜¯å°ˆé–€é¤µçµ¦ AI çš„
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

# ç”¨æ³•æ¸¬è©¦
if __name__ == "__main__":
    # é€ ä¸€å€‹å‡çš„ DataFrame æ¸¬è©¦
    data = {
        'close': [3000, 3010, 3020, 3050, 3040, 3060, 3080, 3100, 3120, 3110, 3150, 3200, 3180, 3190, 3210, 3250, 3300, 3280, 3290, 3310, 3350, 3400, 3380, 3360, 3390, 3410]
    }
    df_test = pd.DataFrame(data)
    
    service = MarketDataService()
    result = service.analyze_technicals(df_test)
    
    print("--- AI æœƒçœ‹åˆ°çš„æ–‡å­— ---")
    print(result['technical_analysis_text'])
--- END OF FILE: services\market_data_service.py ---

--- START OF FILE: services\qa_service.py ---
import json
import os
import config
from datetime import datetime
from typing import List, Dict, Any

class QAService:
    def __init__(self, filename: str = "questions.json"):
        self.filename = filename

    def _load_questions(self) -> List[Dict[str, Any]]:
        """è®€å–å•é¡Œåˆ—è¡¨ (å…§éƒ¨æ–¹æ³•)"""
        if not os.path.exists(self.filename):
            # å¦‚æœæª”æ¡ˆä¸å­˜åœ¨ï¼Œå»ºç«‹ä¸€å€‹ç¯„æœ¬
            default_data = [{"id": "question000", "question": "ç¯„ä¾‹å•é¡Œ", "answered": True}]
            self._save_questions(default_data)
            return default_data
        
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"âš ï¸ è®€å–å•é¡Œæª”å¤±æ•—: {e}")
            return []

    def _save_questions(self, data: List[Dict[str, Any]]) -> None:
        """å„²å­˜å•é¡Œåˆ—è¡¨ (å…§éƒ¨æ–¹æ³•)"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

    def _format_email_content(self, q_id: str, question: str, answer_html: str) -> str:
        """ç”Ÿæˆ Email çš„ HTML å…§å®¹"""
        return f"""
        <div style="background-color: #f8f9fa; padding: 15px; border-left: 5px solid #0d6efd; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; color: #0d6efd;">ğŸ“Œ æå•ç·¨è™Ÿ: {q_id}</h3>
            <p style="font-size: 16px; font-weight: bold; margin: 0; line-height: 1.5;">
                {question}
            </p>
        </div>
        
        <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">
        
        <div style="font-family: Arial, sans-serif; line-height: 1.6;">
            {answer_html}
        </div>
        """

    def mark_as_answered(self, question_id: str) -> None:
        """å°‡å•é¡Œæ¨™è¨˜ç‚ºå·²å›ç­”"""
        questions = self._load_questions()
        updated = False
        
        for q in questions:
            if q.get('id') == question_id:
                q['answered'] = True
                q['answered_at'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                updated = True
                break
        
        if updated:
            self._save_questions(questions)

    def process_pending_questions(self, ai_reporter, mailer) -> None:
        """
        æ ¸å¿ƒæ¥­å‹™é‚è¼¯ï¼šæª¢æŸ¥ä¸¦è™•ç†æ‰€æœ‰æœªå›ç­”çš„å•é¡Œ
        :param ai_reporter: è² è²¬ç”Ÿæˆå›ç­”çš„ç‰©ä»¶
        :param mailer: è² è²¬ç™¼é€éƒµä»¶çš„ç‰©ä»¶
        """
        if not getattr(config, 'ENABLE_QA_SYSTEM', False):
            return

        questions = self._load_questions()
        pending_count = 0

        # ç¯©é¸å‡ºæœªå›ç­”çš„å•é¡Œ
        pending_questions = [q for q in questions if not q.get('answered', False)]

        if not pending_questions:
            return

        for q in pending_questions:
            q_id = q.get('id', 'unknown')
            q_text = q.get('question', '')
            
            print(f"\nğŸ’¡ ç™¼ç¾æ–°å•é¡Œ ({q_id}): {q_text}")
            print("ğŸ¤– AI æ­£åœ¨æ€è€ƒç­”æ¡ˆ...")

            try:
                # 1. AI ç”Ÿæˆç­”æ¡ˆ
                # å‡è¨­ ai_reporter æœ‰ generate_free_qa æ–¹æ³•
                answer_html = ai_reporter.generate_free_qa(q_text)
                
                # 2. çµ„åˆ Email å…§å®¹
                email_subject = f"ğŸ§  AI å•ç­”å›è¦†: {q_id}"
                email_body = self._format_email_content(q_id, q_text, answer_html)

                # 3. ç™¼é€éƒµä»¶
                mailer.send_report(email_subject, email_body)
                print(f"ğŸ“¨ å›è¦†å·²å¯„å‡º: {q_id}")

                # 4. æ¨™è¨˜ç‚ºå·²å›ç­” (æ›´æ–°ç‹€æ…‹)
                # é€™è£¡ç›´æ¥å‘¼å« mark_as_answered æœƒé‡æ–°è®€å¯«ä¸€æ¬¡æª”æ¡ˆï¼Œé›–ç„¶ IO å¤šä¸€é»ä½†æ¯”è¼ƒå®‰å…¨
                self.mark_as_answered(q_id)
                pending_count += 1

            except Exception as e:
                print(f"âŒ è™•ç†å•é¡Œ {q_id} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
                # å¯ä»¥åœ¨é€™è£¡åŠ å…¥éŒ¯èª¤ logging æˆ–é€šçŸ¥ç®¡ç†å“¡

        if pending_count > 0:
            print(f"âœ… æœ¬æ¬¡å…±è™•ç†äº† {pending_count} å€‹å•é¡Œ")
--- END OF FILE: services\qa_service.py ---

--- START OF FILE: services\report_service.py ---
import google.generativeai as genai
import config
from typing import Dict, Any

class ReportService:
    def __init__(self):
        # è¨­å®š Gemini API
        genai.configure(api_key=config.GEMINI_API_KEY)
        self.model = genai.GenerativeModel(config.GEMINI_MODEL_NAME)

    def _generate_html(self, prompt: str) -> str:
        """å…§éƒ¨æ–¹æ³•ï¼šå‘¼å« AI ä¸¦æ¸…ç†è¼¸å‡º"""
        try:
            response = self.model.generate_content(prompt)
            # æ¸…ç†å¯èƒ½å‡ºç¾çš„ markdown æ¨™è¨˜
            return response.text.replace("```html", "").replace("```", "").strip()
        except Exception as e:
            print(f"âŒ AI å ±å‘Šç”Ÿæˆå¤±æ•—: {e}")
            return "<p>âš ï¸ å ±å‘Šç”Ÿæˆç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚</p>"

    def generate_entry_report(self, context: Dict[str, Any]) -> str:
        """
        ç”Ÿæˆäº¤æ˜“é€²å ´å ±å‘Š
        """
        # å‹•æ…‹æ±ºå®šèƒŒæ™¯è‰²
        bg_color = '#e6f4ea' if 'LONG' in context.get('trend_signal', '') else '#fce8e6'
        
        prompt = f"""
        ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„é‡åŒ–äº¤æ˜“åŠ©ç†ã€‚è«‹æ ¹æ“šä»¥ä¸‹æ•¸æ“šå¯«ä¸€ä»½ **HTML äº¤æ˜“å¿«è¨Š**ã€‚
        
        ã€äº¤æ˜“è³‡è¨Šã€‘
        - æ¨™çš„: {context.get('symbol')}
        - è¨Šè™Ÿ: {context.get('trend_signal')}
        - ç¾åƒ¹: {context.get('close')}
        - æ™‚é–“: {context.get('time')}
        
        ã€æŠ€è¡“æŒ‡æ¨™æ•¸æ“šã€‘
        {context.get('technical_analysis_text')}
        
        ã€è¼¸å‡ºè¦æ±‚ã€‘
        1. HTML æ ¼å¼ï¼ŒèƒŒæ™¯è‰²ä½¿ç”¨ {bg_color}ã€‚
        2. æ¨™é¡Œ: äº¤æ˜“è¨Šè™Ÿ ({context.get('symbol')} {context.get('trend_signal')})ã€‚
        3. ç”¨è¡¨æ ¼å‘ˆç¾æŠ€è¡“æŒ‡æ¨™æ•¸æ“šã€‚
        4. æ ¹æ“šæ•¸æ“šç°¡çŸ­åˆ†æé€²å ´ç†ç”±ã€‚
        5. çµ¦å‡ºæ­¢æ/æ­¢ç›ˆå»ºè­°ã€‚
        6. åªè¼¸å‡º HTML ä»£ç¢¼ï¼Œä¸è¦æœ‰ Markdownã€‚
        """
        return self._generate_html(prompt)

    def generate_market_report(self, context: Dict[str, Any]) -> str:
        """
        ç”Ÿæˆå®šæœŸå¸‚å ´é€±å ±
        """
        prompt = f"""
        ä½ æ˜¯ä¸€å€‹è³‡æ·±çš„åŠ å¯†è²¨å¹£åˆ†æå¸«ã€‚è«‹æ ¹æ“šä»¥ä¸‹æ•¸æ“šå¯«ä¸€ä»½ **HTML å¸‚å ´è¶¨å‹¢æ—¥å ±**ã€‚
        
        ã€å¸‚å ´è³‡è¨Šã€‘
        - æ¨™çš„: {context.get('symbol')}
        - å ±å‘Šæ™‚é–“: {context.get('time')}
        
        ã€æŠ€è¡“åˆ†ææ‘˜è¦ã€‘
        {context.get('technical_analysis_text')}
        
        ã€è¼¸å‡ºè¦æ±‚ã€‘
        1. é¢¨æ ¼å°ˆæ¥­ã€å®¢è§€ï¼Œæ¨™é¡ŒèƒŒæ™¯è‰²ä½¿ç”¨ #e8f0feã€‚
        2. **å¸‚å ´è§£è®€**: åˆ¤æ–·ç›®å‰æ˜¯å¤§è¶¨å‹¢å¤šé ­ã€ç©ºé ­é‚„æ˜¯ç›¤æ•´ã€‚
        3. **é—œéµé»ä½**: åˆ†ææ”¯æ’èˆ‡å£“åŠ›ã€‚
        4. **æ“ä½œå»ºè­°**: é‡å°ç©ºæ‰‹è€…èˆ‡æŒå€‰è€…çµ¦äºˆå»ºè­°ã€‚
        5. åªè¼¸å‡º HTML ä»£ç¢¼ã€‚
        """
        return self._generate_html(prompt)

    def generate_free_qa(self, user_question: str) -> str:
        """
        QA ç³»çµ±å°ˆç”¨ä»‹é¢ (é…åˆ qa_service.py)
        """
        prompt = f"""
        ä½¿ç”¨è€…å•é¡Œ: {user_question}
        
        è«‹ä»¥ã€ŒåŠ å¯†è²¨å¹£èˆ‡é‡‘èäº¤æ˜“é¡§å•ã€çš„èº«åˆ†å›ç­”ï¼š
        1. ä½¿ç”¨ HTML æ ¼å¼ (ä¸å« ``` æ¨™è¨˜)ã€‚
        2. é‡é»åŠ ç²—ã€‚
        3. èªæ°£å°ˆæ¥­è¦ªåˆ‡ã€‚
        """
        return self._generate_html(prompt)
--- END OF FILE: services\report_service.py ---

--- START OF FILE: services\trading_service.py ---
import config
from datetime import datetime
import time

# å¼•å…¥æ ¸å¿ƒå·¥å…·
from services.market_data_service import MarketDataService
from utils.data_loader import BingXLoader
from utils.executor import BingXExecutor
from utils.trade_logger import TradeLogger

class TradingService:
    def __init__(self, report_service=None, email_service=None):
        """
        æ•´åˆæ‰€æœ‰äº¤æ˜“ç›¸é—œçš„å…ƒä»¶
        """
        self.report_service = report_service
        self.email_service = email_service
        
        # 1. æ•¸æ“šæœå‹™ (è¨ˆç®—æŒ‡æ¨™)
        self.market_data_service = MarketDataService()
        
        # 2. äº¤æ˜“æ‰€é€£ç·š (BingX)
        self.loader = BingXLoader()
        self.executor = BingXExecutor(self.loader.exchange)
        
        # 3. æ—¥èªŒè¨˜éŒ„
        self.logger = TradeLogger()

        self.symbols = config.COIN_LIST

    def run_cycle(self):
        """
        åŸ·è¡Œä¸€æ¬¡å®Œæ•´çš„äº¤æ˜“å¾ªç’°
        """
        print(f"ğŸ”¨ TradingService: é–‹å§‹æƒæå¸‚å ´ ({config.TRADE_TIMEFRAME})...")

        for symbol in self.symbols:
            try:
                # ----------------------------------------
                # Step 1: ç²å–çœŸå¯¦æ•¸æ“š
                # ----------------------------------------
                df = self.loader.fetch_data(
                    timeframe=config.TRADE_TIMEFRAME, 
                    symbol=symbol, 
                    limit=50 # åªéœ€è¦è¶³å¤ è¨ˆç®— MA25 å³å¯
                )
                
                if df is None or df.empty:
                    print(f"   âš ï¸ è·³é {symbol}: ç„¡æ³•ç²å–æ•¸æ“š")
                    continue

                # ----------------------------------------
                # Step 2: è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ (AIContext)
                # ----------------------------------------
                context = self.market_data_service.analyze_technicals(df)
                context['symbol'] = symbol
                
                # ----------------------------------------
                # Step 3: æª¢æŸ¥ç•¶å‰å€‰ä½
                # ----------------------------------------
                # æ¨¡æ“¬æ¨¡å¼ä¸‹ï¼Œexecutor æœƒå¾è¨˜æ†¶é«”è®€å–ï¼›çœŸå¯¦æ¨¡å¼æœƒæ‰“ API
                current_position = self.executor.get_open_position(symbol)
                
                # ----------------------------------------
                # Step 4: ç­–ç•¥é‚è¼¯ (Golden Cross / Death Cross)
                # ----------------------------------------
                signal = context.get('trend_signal') # LONG / SHORT
                close_price = context.get('close')
                
                # å–å¾—è©²å¹£ç¨®è¨­å®šçš„ä¸‹å–®é‡
                order_amount = config.ORDER_SIZES.get(symbol, config.ORDER_AMOUNT)

                # å°å‡ºç°¡æ˜“ç‹€æ…‹
                pos_status = current_position if current_position else "EMPTY"
                print(f"   [{symbol}] ${close_price:.2f} | è¨Šè™Ÿ:{signal} | æŒå€‰:{pos_status} | RSI:{context['rsi']:.1f}")

                # --- é€²å ´é‚è¼¯ ---
                if current_position is None:
                    if signal == "LONG":
                        self._execute_trade("buy", symbol, order_amount, close_price, "MAé‡‘å‰åšå¤š", context)
                    elif signal == "SHORT":
                        self._execute_trade("sell", symbol, order_amount, close_price, "MAæ­»å‰åšç©º", context)
                
                # --- å‡ºå ´é‚è¼¯ (ç°¡å–®åå‘å¹³å€‰) ---
                # å¦‚æœæŒå¤šå–®ï¼Œä½†è¨Šè™Ÿè½‰ç©º -> å¹³å€‰
                elif current_position == "LONG" and signal == "SHORT":
                    self._close_trade(symbol, close_price, "è¨Šè™Ÿåè½‰å¹³å¤š")
                
                # å¦‚æœæŒç©ºå–®ï¼Œä½†è¨Šè™Ÿè½‰å¤š -> å¹³å€‰
                elif current_position == "SHORT" and signal == "LONG":
                    self._close_trade(symbol, close_price, "è¨Šè™Ÿåè½‰å¹³ç©º")

            except Exception as e:
                print(f"   âŒ è™•ç† {symbol} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

    def _execute_trade(self, side, symbol, amount, price, tag, context):
        """åŸ·è¡Œä¸‹å–®ä¸¦ç™¼é€é€šçŸ¥"""
        print(f"   ğŸš€ è§¸ç™¼ä¸‹å–®: {symbol} {side} ({tag})")
        
        # 1. åŸ·è¡Œä¸‹å–®
        order = self.executor.place_order(side, symbol, amount)
        
        if order or config.DRY_RUN:
            # 2. å¯«å…¥ Log
            self.logger.log(side.upper(), price, amount, tag, symbol=symbol)
            
            # 3. ç™¼é€ AI å ±å‘Šèˆ‡ Email
            if self.report_service and self.email_service:
                # è£œå…… context è³‡è¨Š
                context['action'] = side.upper()
                context['price'] = price
                
                html_report = self.report_service.generate_entry_report(context)
                subject = f"ğŸš€ äº¤æ˜“å¿«è¨Š: {symbol} {side.upper()} ({tag})"
                self.email_service.send_report(subject, html_report)

    def _close_trade(self, symbol, price, tag):
        """åŸ·è¡Œå¹³å€‰"""
        print(f"   ğŸ‘‹ è§¸ç™¼å¹³å€‰: {symbol} ({tag})")
        
        # 1. åŸ·è¡Œå¹³å€‰
        self.executor.close_position(symbol)
        
        # 2. å¯«å…¥ Log (å¹³å€‰æš«æ™‚è¨˜éŒ„ amount=0 æˆ–ä¾æ“šé‚è¼¯èª¿æ•´)
        self.logger.log("CLOSE", price, 0, tag, symbol=symbol)
--- END OF FILE: services\trading_service.py ---

--- START OF FILE: utils\data_loader.py ---
import ccxt
import pandas as pd
import config
import time

class BingXLoader:
    def __init__(self):
        # åˆå§‹åŒ–äº¤æ˜“æ‰€ç‰©ä»¶
        self.exchange = ccxt.bingx({
            'enableRateLimit': True, # å•Ÿç”¨é€Ÿç‡é™åˆ¶ï¼Œé¿å…è¢«é– IP
        })

    def fetch_data(self, timeframe, symbol=None, limit=100):
        """
        å¾ BingX ç²å– K ç·šæ•¸æ“š
        :param timeframe: æ™‚æ¡† (ä¾‹å¦‚ '15m', '1h')
        :param symbol: äº¤æ˜“å° (ä¾‹å¦‚ 'BTC-USDT')ï¼Œå¦‚æœç‚º None å‰‡å˜—è©¦è®€å– config
        :param limit: ç²å– K ç·šçš„æ•¸é‡
        """
        # 1. è™•ç† Symbol (å„ªå…ˆä½¿ç”¨å‚³å…¥çš„åƒæ•¸ï¼Œå¦å‰‡ä½¿ç”¨ config é è¨­)
        if symbol is None:
            if hasattr(config, 'SYMBOL'):
                symbol = config.SYMBOL
            elif hasattr(config, 'COIN_LIST') and config.COIN_LIST:
                symbol = config.COIN_LIST[0]
            else:
                print("âŒ éŒ¯èª¤: æœªæŒ‡å®š Symbol ä¸” Config ä¸­æ‰¾ä¸åˆ°è¨­å®š")
                return None

        # CCXT é€šå¸¸éœ€è¦ 'BTC/USDT' æ ¼å¼ï¼Œè€Œæˆ‘å€‘ config å¯èƒ½å¯« 'BTC-USDT'
        formatted_symbol = symbol.replace('-', '/')

        try:
            # print(f"ğŸ“¥ æ­£åœ¨ç²å– {formatted_symbol} çš„ {timeframe} K ç·šæ•¸æ“š...")
            
            # 2. å‘¼å« CCXT API
            ohlcv = self.exchange.fetch_ohlcv(formatted_symbol, timeframe, limit=limit)
            
            if not ohlcv:
                print(f"âš ï¸ {symbol} ç²å–æ•¸æ“šç‚ºç©º")
                return None

            # 3. è½‰æ›ç‚º DataFrame
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # è™•ç†æ™‚é–“æˆ³ (è½‰ç‚ºäººé¡å¯è®€æ™‚é–“ï¼Œæ–¹ä¾¿é™¤éŒ¯)
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            
            # ç¢ºä¿æ•¸æ“šæ˜¯ float æ ¼å¼
            df = df.astype({
                'open': 'float',
                'high': 'float',
                'low': 'float',
                'close': 'float',
                'volume': 'float'
            })
            
            return df

        except Exception as e:
            print(f"âŒ {symbol} æ•¸æ“šç²å–å¤±æ•—: {e}")
            return None

# ç°¡å–®æ¸¬è©¦ç”¨
if __name__ == "__main__":
    loader = BingXLoader()
    # æ¸¬è©¦å¤šå¹£ç¨®å‚³åƒ
    df = loader.fetch_data(timeframe='15m', symbol='BTC-USDT')
    if df is not None:
        print(f"âœ… BTC-USDT æ¸¬è©¦æˆåŠŸ:\n{df.tail(2)}")
--- END OF FILE: utils\data_loader.py ---

--- START OF FILE: utils\executor.py ---
import ccxt
import config

class BingXExecutor:
    def __init__(self, exchange):
        self.exchange = exchange
        self.dry_run = config.DRY_RUN
        
        # æ¨¡æ“¬å€‰ä½å„²å­˜: {'BTC-USDT': 'LONG', ...}
        self.simulated_positions = {} 
        
        if not self.dry_run:
            print("âš™ï¸ [Executor] æ­£åœ¨ç‚ºç›£æ§æ¸…å–®è¨­å®šæ§“æ¡¿...")
            for symbol in config.COIN_LIST:
                self.set_leverage(config.LEVERAGE, symbol)

    def set_leverage(self, leverage, symbol):
        if self.dry_run: return 
        try:
            self.exchange.set_leverage(leverage, symbol)
        except Exception as e:
            print(f"âš ï¸ è¨­å®šæ§“æ¡¿å¤±æ•— ({symbol}): {e}")

    def get_open_position(self, symbol):
        """å›å‚³ 'LONG', 'SHORT' æˆ– None"""
        if self.dry_run:
            return self.simulated_positions.get(symbol)

        try:
            # é‡å°ç‰¹å®šå¹£ç¨®æŸ¥è©¢çœŸå¯¦å€‰ä½
            # æ³¨æ„: CCXT BingX fetch_positions å¯èƒ½éœ€è¦ symbol æ ¼å¼è½‰æ›
            positions = self.exchange.fetch_positions([symbol.replace('-', '/')])
            for pos in positions:
                # æª¢æŸ¥åˆç´„æ•¸é‡ > 0
                if float(pos['contracts']) > 0:
                    return pos['side'].upper() # LONG / SHORT
            return None
        except Exception as e:
            print(f"âš ï¸ è®€å–å€‰ä½å¤±æ•— ({symbol}): {e}")
            return None

    def place_order(self, side, symbol, amount):
        if self.dry_run:
            print(f"ğŸ§ª [æ¨¡æ“¬] {symbol} ä¸‹å–®: {side.upper()} {amount}")
            # æ›´æ–°æ¨¡æ“¬ç‹€æ…‹
            pos_type = 'LONG' if side == 'buy' else 'SHORT'
            self.simulated_positions[symbol] = pos_type
            return {'id': 'sim_order_id'}

        try:
            print(f"âš¡ [çœŸå¯¦] {symbol} ä¸‹å–®: {side.upper()} {amount} ...")
            order = self.exchange.create_market_order(symbol.replace('-', '/'), side, amount)
            print(f"âœ… ä¸‹å–®æˆåŠŸ! ID: {order['id']}")
            return order
        except Exception as e:
            print(f"âŒ ä¸‹å–®å¤±æ•— ({symbol}): {e}")
            return None
        
    def close_position(self, symbol):
        if self.dry_run:
            if self.simulated_positions.get(symbol):
                print(f"ğŸ§ª [æ¨¡æ“¬] {symbol} å¹³å€‰æˆåŠŸ")
                self.simulated_positions[symbol] = None
            return

        try:
            # çœŸå¯¦å¹³å€‰ï¼šé€šå¸¸ä½¿ç”¨ reduceOnly æˆ–æŸ¥è©¢ç•¶å‰æŒå€‰é‡å¾Œåå‘æ“ä½œ
            # é€™è£¡ç°¡å–®ç¤ºç¯„ï¼šå…ˆæŸ¥æ–¹å‘ï¼Œå†åå‘å¸‚åƒ¹å…¨å¹³
            current_pos = self.get_open_position(symbol)
            if not current_pos:
                return

            side = 'sell' if current_pos == 'LONG' else 'buy'
            # æ³¨æ„ï¼šBingX å¹³å€‰æœ€å¥½å‚³å…¥ reduceOnly: True
            # Amount é€™è£¡æš«æ™‚ç”¨ config çš„è¨­å®šï¼Œç†æƒ³æƒ…æ³æ˜¯è®€å–ç•¶å‰æŒå€‰æ•¸é‡
            amount = config.ORDER_SIZES.get(symbol, config.ORDER_AMOUNT)

            print(f"âš¡ [çœŸå¯¦] {symbol} å¹³å€‰: {side.upper()} ...")
            self.exchange.create_market_order(
                symbol.replace('-', '/'), 
                side, 
                amount, 
                params={'reduceOnly': True} 
            )
            print(f"âœ… {symbol} å¹³å€‰æŒ‡ä»¤å·²ç™¼é€")
            
        except Exception as e:
            print(f"âŒ å¹³å€‰å¤±æ•— ({symbol}): {e}")
--- END OF FILE: utils\executor.py ---

--- START OF FILE: utils\trade_logger.py ---
import json
import os
from datetime import datetime
import config

class TradeLogger:
    def __init__(self, filename="logs/trade_history.json"):
        self.filename = filename
        
        # ç¢ºä¿ log ç›®éŒ„å­˜åœ¨
        log_dir = os.path.dirname(self.filename)
        if log_dir and not os.path.exists(log_dir):
            os.makedirs(log_dir, exist_ok=True)

    def log(self, action, price, amount, tag, pnl=0.0, balance=0.0, symbol=None):
        """
        è¨˜éŒ„äº¤æ˜“åˆ° JSON æª”æ¡ˆ
        :param symbol: äº¤æ˜“å¹£ç¨® (ä¾‹å¦‚ 'BTC-USDT') ğŸ”¥ æ–°å¢é€™å€‹åƒæ•¸
        """
        
        # å¦‚æœå‘¼å«æ™‚æ²’å‚³ symbolï¼Œå˜—è©¦ç”¨ config è£¡çš„é è¨­å€¼ (å…¼å®¹èˆŠç¨‹å¼ç¢¼)
        if symbol is None:
            if hasattr(config, 'SYMBOL'):
                symbol = config.SYMBOL
            elif hasattr(config, 'COIN_LIST') and config.COIN_LIST:
                symbol = config.COIN_LIST[0]
            else:
                symbol = "UNKNOWN"

        record = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "symbol": symbol,  # ğŸ”¥ å¯«å…¥å¹£ç¨®
            "action": action,
            "price": float(price),
            "amount": float(amount),
            "tag": tag,
            "realized_pnl": float(pnl),
            "balance": float(balance)
        }

        # è®€å–ç¾æœ‰ç´€éŒ„
        history = []
        if os.path.exists(self.filename):
            try:
                with open(self.filename, "r", encoding="utf-8") as f:
                    history = json.load(f)
            except Exception:
                history = []

        # åŠ å…¥æ–°ç´€éŒ„
        history.append(record)

        # å¯«å›æª”æ¡ˆ
        try:
            with open(self.filename, "w", encoding="utf-8") as f:
                json.dump(history, f, indent=4, ensure_ascii=False)
            print(f"ğŸ“ [Log] {symbol} äº¤æ˜“ç´€éŒ„å·²æ›´æ–°: {action} @ {price}")
        except Exception as e:
            print(f"âŒ [Log] å¯«å…¥å¤±æ•—: {e}")

# æ¸¬è©¦ç”¨
if __name__ == "__main__":
    logger = TradeLogger()
    logger.log("TEST_ENTRY", 50000, 0.001, "æ¸¬è©¦å¯«å…¥", symbol="BTC-USDT")
--- END OF FILE: utils\trade_logger.py ---
