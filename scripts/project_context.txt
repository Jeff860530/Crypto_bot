=== PROJECT STRUCTURE ===
crypto_bot/
    .gitignore
    config.py
    main.py
    questions.json
    Readme.txt
    requirements.txt
    scripts/
        export_context.py
    services/
        email_service.py
        market_data_service.py
        qa_service.py
        report_service.py
        trading_service.py
    strategies/
        base_strategy.py
        harmonic_strategy.py
        ma_cross_strategy.py
        __init__.py
    test/
        run_tests.py
    utils/
        data_loader.py
        executor.py
        trade_logger.py
        zigzag.py

==================================================

=== FILE CONTENTS ===

--- START OF FILE: config.py ---
# config.py
from gitIgnoreFile.MyKey import myApiKey, mySecretKey
from gitIgnoreFile.MyMail import EmailSender, EmailPassword, EmailReceiver
from gitIgnoreFile.MyGeminiKey import MyGeminiApiKey, MyGeminiAiName

# --- BingX API è¨­å®š ---
API_KEY = myApiKey
SECRET_KEY = mySecretKey

# --- äº¤æ˜“æ¨™çš„èˆ‡è³‡é‡‘ç®¡ç† ---
COIN_LIST = [
    # "BTC-USDT",
    "ETH-USDT"
]

DRY_RUN = True  # True: æ¨¡æ“¬äº¤æ˜“ | False: çœŸå¯¦ä¸‹å–®
LEVERAGE = 5
TRADING_FEE_RATE = 0.0005

# é è¨­ä¸‹å–®æ•¸é‡ (ç•¶æ‰¾ä¸åˆ° ORDER_SIZES æ™‚ä½¿ç”¨)
ORDER_AMOUNT = 0.001 

# å€‹åˆ¥å¹£ç¨®ä¸‹å–®é‡ (å»ºè­°ç´„ 10~100 USDT)
ORDER_SIZES = {
    "BTC-USDT": 0.001,   # ç´„ 90 U
    "ETH-USDT": 0.01,    # ç´„ 25 U
    "SOL-USDT": 0.5,     # ç´„ 50 U
    "DOGE-USDT": 100,    # ç´„ 30 U
    "BNB-USDT": 0.1      # ç´„ 60 U
}

# --- ç­–ç•¥èˆ‡æŒ‡æ¨™åƒæ•¸ ---
TRADE_TIMEFRAME = '15m'
SMA_SHORT = 7
SMA_LONG = 25
KDJ_LENGTH = 9
KDJ_SIGNAL = 3
ZIGZAG_ORDER = 5

# ğŸ”¥ æ–°å¢ï¼šå•Ÿç”¨ç­–ç•¥æ¸…å–®
# ç³»çµ±æœƒä¾åºè¼‰å…¥é€™äº›ç­–ç•¥
ACTIVE_STRATEGIES = [
    "MACrossStrategy",
    "HarmonicStrategy",
    # "RsiReversalStrategy"
]

# é¢¨æ§ (0.02 = 2%)
STOP_LOSS_PCT = 0.02      
TAKE_PROFIT_PCT = 0.04 

# --- ç³»çµ±æœå‹™è¨­å®š ---

# 1. Email (SMTP)
ENABLE_EMAIL = True
SMTP_SERVER = "smtp.gmail.com"
SMTP_PORT = 587
SMTP_USERNAME = EmailSender
SMTP_PASSWORD = EmailPassword
SMTP_TO_EMAIL = EmailReceiver

# 2. Gemini AI
GEMINI_API_KEY = MyGeminiApiKey
GEMINI_MODEL_NAME = MyGeminiAiName

# True: çœŸå¯¦å‘¼å« Gemini (æ¶ˆè€—é¡åº¦)
# False: ä½¿ç”¨æ¨¡æ“¬å‡è³‡æ–™ (å¿«é€Ÿæ¸¬è©¦ç”¨)
ENABLE_AI_GENERATION = True

# 3. ç³»çµ±åŠŸèƒ½é–‹é—œ
# (True: é–‹å•Ÿ | False: æš«åœ)
ENABLE_QA_SYSTEM = True        # æ˜¯å¦é–‹å•Ÿå•ç­”ç³»çµ±
ENABLE_TRADING_SYSTEM = True   # æ˜¯å¦é–‹å•Ÿäº¤æ˜“ç­–ç•¥æª¢æŸ¥
ENABLE_PERIODIC_REPORT = False  # æ˜¯å¦é–‹å•Ÿå®šæœŸå ±å‘Š

# --------------------------------------------------------
# â±ï¸ æœå‹™åŸ·è¡Œé »ç‡è¨­å®š (å–®ä½: ç§’)
# --------------------------------------------------------
# èªªæ˜: æ”¯æ´æ•¸å­¸é‹ç®—ï¼Œä¾‹å¦‚ 15 * 60 ä»£è¡¨ 15 åˆ†é˜
# --------------------------------------------------------

# QA å•ç­”æª¢æŸ¥é »ç‡ (å»ºè­° 5~10 ç§’)
INTERVAL_QA_CHECK = 5 

# äº¤æ˜“ç­–ç•¥æª¢æŸ¥é »ç‡ (å»ºè­°é…åˆ K ç·šæ™‚æ¡†ï¼Œä¾‹å¦‚ 15 åˆ†é˜)
# INTERVAL_TRADING_CHECK = 15 * 60
INTERVAL_TRADING_CHECK = 1 * 60 * 60

# å®šæœŸå¸‚å ´å ±å‘Šé »ç‡ (ä¾‹å¦‚æ¯ 60 åˆ†é˜ç™¼ä¸€æ¬¡)
# INTERVAL_PERIODIC_REPORT = 60 * 60
INTERVAL_PERIODIC_REPORT = 1 * 60 * 60
--- END OF FILE: config.py ---

--- START OF FILE: main.py ---
import time
from datetime import datetime, timedelta
import config

# å¼•å…¥æœå‹™æ¨¡çµ„
from services.trading_service import TradingService
from services.report_service import ReportService
from services.qa_service import QAService
from services.email_service import EmailService
from services.market_data_service import MarketDataService
from utils.data_loader import BingXLoader

def main():
    print(f"ğŸ¤– Crypto Bot æ¶æ§‹é‡æ§‹ç‰ˆå•Ÿå‹•...")

    # 1. åˆå§‹åŒ–æœå‹™
    mailer = EmailService()            
    reporter = ReportService()        
    market_data = MarketDataService() 
    qa_service = QAService("questions.json")

    loader = BingXLoader()
    trader = TradingService(report_service=reporter, email_service=mailer) 

    # 2. è¨­å®šæ™‚é–“é– (Time Locks)
    timers = {
        'trade': datetime.now(),         # é¦¬ä¸ŠåŸ·è¡Œä¸€æ¬¡
        'report': datetime.now(),        # é¦¬ä¸ŠåŸ·è¡Œä¸€æ¬¡
        'qa': datetime.now()             # é¦¬ä¸ŠåŸ·è¡Œä¸€æ¬¡
    }

    # é¡¯ç¤ºç›®å‰çš„é »ç‡è¨­å®š
    print("ğŸš€ ç³»çµ±é€²å…¥æ¥µé€Ÿç›£è½æ¨¡å¼...")
    print(f"   â±ï¸ QAæª¢æŸ¥: æ¯ {config.INTERVAL_QA_CHECK} ç§’")
    print(f"   â±ï¸ äº¤æ˜“æª¢æŸ¥: æ¯ {config.INTERVAL_TRADING_CHECK / 60:.0f} åˆ†é˜")
    print(f"   â±ï¸ å®šæœŸå ±å‘Š: æ¯ {config.INTERVAL_PERIODIC_REPORT / 60:.0f} åˆ†é˜")
    print("-" * 50) # åˆå§‹åˆ†éš”ç·š

    while True:
        try:
            now = datetime.now()

            # --- ä»»å‹™ 1: QA å•ç­” ---
            if config.ENABLE_QA_SYSTEM and now >= timers['qa']:
                # åŸ·è¡Œ QA é‚è¼¯
                qa_service.process_pending_questions(ai_reporter=reporter, mailer=mailer)
                
                # é‡è¨­è¨ˆæ™‚å™¨
                timers['qa'] = now + timedelta(seconds=config.INTERVAL_QA_CHECK)
                
                # ğŸ”¥ å„ªåŒ–ï¼šä»»å‹™çµæŸå¾Œå¤šå°ä¸€è¡Œç©ºè¡Œï¼Œæ–¹ä¾¿é–±è®€
                # (å› ç‚º QA æ¯”è¼ƒé »ç¹ï¼Œå¦‚æœä¸å¸Œæœ›å®ƒä¸€ç›´åˆ·ç©ºè¡Œï¼Œå¯ä»¥åªåœ¨æœ‰è™•ç†å•é¡Œæ™‚å°ï¼Œ
                # ä½†ç‚ºäº†ä¿æŒç¨‹å¼ç¢¼ç°¡å–®ä¸€è‡´ï¼Œé€™è£¡å…ˆçµ±ä¸€å°å‡º)
                # print() 

            # --- ä»»å‹™ 2: äº¤æ˜“æª¢æŸ¥ ---
            if config.ENABLE_TRADING_SYSTEM and now >= timers['trade']:
                print(f"ğŸ’° åŸ·è¡Œäº¤æ˜“ç­–ç•¥æª¢æŸ¥... {now.strftime('%H:%M')}")
                trader.run_cycle() 
                
                # é‡è¨­è¨ˆæ™‚å™¨
                timers['trade'] = now + timedelta(seconds=config.INTERVAL_TRADING_CHECK)
                
                # ğŸ”¥ å„ªåŒ–ï¼šä»»å‹™çµæŸå¾Œå¤šå°ä¸€è¡Œç©ºè¡Œ
                print("-" * 30 + "\n") 

            # --- ä»»å‹™ 3: å®šæœŸå ±å‘Š ---
            if config.ENABLE_PERIODIC_REPORT and now >= timers['report']:
                print(f"ğŸ“Š åŸ·è¡Œå®šæœŸå¸‚å ´å ±å‘Š... {now.strftime('%H:%M')}")
                
                # é‡å°ç›£æ§æ¸…å–®ä¸­çš„æ¯ä¸€å€‹å¹£ç¨®ç”Ÿæˆå ±å‘Š
                for symbol in config.COIN_LIST:
                    try:
                        # 1. æŠ“è³‡æ–™ (æŠ“ 1 å°æ™‚ç·šä¾†çœ‹å¤§è¶¨å‹¢)
                        df = loader.fetch_data(timeframe='1h', symbol=symbol, limit=50)
                        
                        if df is not None and not df.empty:
                            # 2. ç®—æŒ‡æ¨™
                            context = market_data.analyze_technicals(df)
                            context['symbol'] = symbol
                            
                            # 3. ç”Ÿæˆ HTML
                            html = reporter.generate_market_report(context)
                            
                            # 4. å¯„ä¿¡
                            subject = f"ğŸ“… å¸‚å ´è¶¨å‹¢å ±å‘Š: {symbol}"
                            mailer.send_report(subject, html)
                            print(f"   âœ… {symbol} å ±å‘Šå·²å¯„å‡º")
                        else:
                            print(f"   âš ï¸ {symbol} ç„¡æ³•ç²å–æ•¸æ“šï¼Œè·³éå ±å‘Š")
                            
                    except Exception as e:
                        print(f"   âŒ {symbol} å ±å‘Šç”ŸæˆéŒ¯èª¤: {e}")

                # é‡è¨­è¨ˆæ™‚å™¨
                timers['report'] = now + timedelta(seconds=config.INTERVAL_PERIODIC_REPORT)
                
                # ğŸ”¥ å„ªåŒ–ï¼šä»»å‹™çµæŸå¾Œå¤šå°ä¸€è¡Œç©ºè¡Œ
                print("-" * 30 + "\n")

            # æ¥µé€Ÿè¿´åœˆä¼‘æ¯
            time.sleep(1)

        except KeyboardInterrupt:
            print("\nğŸ›‘ ç¨‹å¼æ‰‹å‹•åœæ­¢")
            break
        except Exception as e:
            print(f"âŒ ä¸»è¿´åœˆç™¼ç”ŸéŒ¯èª¤: {e}")
            time.sleep(10)

if __name__ == "__main__":
    main()
--- END OF FILE: main.py ---

--- START OF FILE: questions.json ---
[
    {
        "id": "question001",
        "question": "è«‹å¹«æˆ‘èªªæ˜ä»€éº¼æ˜¯ RSI KDJ WR MACD",
        "answered": true,
        "frequency": 0,
        "answered_at": "2025-12-18 22:31:22"
    },
    {
        "id": "question002",
        "question": "è«‹å¹«æˆ‘èªªæ˜å¦‚ä½•è§€å¯ŸRSI KDJ WR MACD å¯ä»¥çŸ¥é“å‡çªç ´ é‚„æ˜¯å¤šé ­å›æ¡",
        "answered": true,
        "frequency": 0,
        "answered_at": "2025-12-18 22:33:54"
    },
    {
        "id": "question003",
        "question": "è«‹å¹«æˆ‘åˆ†æ72å°æ™‚çš„ETH 15åˆ†K ",
        "answered": true,
        "frequency": 0,
        "answered_at": "2025-12-28 23:28:10"
    },
    {
        "id": "question004",
        "question": "è«‹å¹«æˆ‘åˆ†æ72å°æ™‚çš„BTC 15åˆ†K",
        "answered": true,
        "frequency": 0,
        "answered_at": "2025-12-18 22:18:35"
    },
    {
        "id": "question005",
        "question": "æˆ‘ç›®å‰æ˜¯å¹¼æ•™è€å¸«éœ€è¦ä½ å¹«æˆ‘è¦åŠƒè½‰æˆUIUX å·¥ç¨‹å¸«",
        "answered": true,
        "answered_at": "2025-12-18 22:24:08"
    }
]
--- END OF FILE: questions.json ---

--- START OF FILE: Readme.txt ---
=== PROJECT STRUCTURE ===
crypto_bot/
    .gitignore                  => è¨­å®š Git ç‰ˆæœ¬æ§åˆ¶æ‡‰å¿½ç•¥çš„æª”æ¡ˆèˆ‡è³‡æ–™å¤¾ (å¦‚æ•æ„Ÿé‡‘é‘°ã€è™›æ“¬ç’°å¢ƒ)
    config.py                   => é›†ä¸­ç®¡ç† API é‡‘é‘°ã€ç­–ç•¥åƒæ•¸ã€é¢¨éšªæ§åˆ¶èˆ‡ç³»çµ±è¨­å®š
    main.py                     => ç¨‹å¼å…¥å£é»ï¼Œè² è²¬çµ„è£æœå‹™ã€å•Ÿå‹•è¿´åœˆèˆ‡æ’ç¨‹ç®¡ç†
    questions.json              => å„²å­˜ä½¿ç”¨è€…æå•å…§å®¹èˆ‡å›ç­”ç‹€æ…‹çš„è³‡æ–™æª”
    Readme.txt                  => å°ˆæ¡ˆæ¶æ§‹èªªæ˜èˆ‡é–‹ç™¼æ–‡ä»¶
    requirements.txt            => åˆ—å‡ºå°ˆæ¡ˆåŸ·è¡Œæ‰€éœ€çš„ Python å¥—ä»¶æ¸…å–®

    scripts/
        export_context.py       => é–‹ç™¼è¼”åŠ©å·¥å…·ï¼Œå°‡å°ˆæ¡ˆç¨‹å¼ç¢¼åŒ¯å‡ºç‚ºå–®ä¸€æ–‡å­—æª”ä»¥ä¾¿ AI Review

    services/
        email_service.py        => å°è£ SMTP å”å®šï¼Œè² è²¬ç™¼é€ HTML æ ¼å¼çš„éƒµä»¶é€šçŸ¥
        market_data_service.py  => è² è²¬è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ (RSI, MA) ä¸¦ç”Ÿæˆå¸‚å ´åˆ†ææ‘˜è¦
        qa_service.py           => ç®¡ç†å•ç­”æµç¨‹ï¼Œå”èª¿ AI å›ç­”å•é¡Œä¸¦æ›´æ–°è™•ç†ç‹€æ…‹
        report_service.py       => è² è²¬ Prompt Engineeringï¼Œå‘¼å« AI ç”Ÿæˆ HTML åˆ†æå ±å‘Š
        trading_service.py      => æ ¸å¿ƒäº¤æ˜“å¤§è…¦ï¼Œæ•´åˆæ•¸æ“šåˆ†æã€ç­–ç•¥åˆ¤æ–·èˆ‡è§¸ç™¼ä¸‹å–®

    utils/
        data_loader.py          => é€é CCXT å¥—ä»¶å¾äº¤æ˜“æ‰€ç²å– K ç·šæ•¸æ“š (OHLCV)
        executor.py             => è² è²¬åŸ·è¡ŒçœŸå¯¦ä¸‹å–®ã€æ¨¡æ“¬äº¤æ˜“èˆ‡å€‰ä½ç®¡ç†
        trade_logger.py         => å°‡æ‰€æœ‰äº¤æ˜“å‹•ä½œèˆ‡æç›Šçµæœè¨˜éŒ„è‡³ JSON æª”æ¡ˆ

==================================================
--- END OF FILE: Readme.txt ---

--- START OF FILE: requirements.txt ---
ccxt
pandas
pandas_ta
--- END OF FILE: requirements.txt ---

--- START OF FILE: scripts\export_context.py ---
import os
import fnmatch

# ğŸ”¥ 1. è·¯å¾‘è¨­å®š
# CURRENT_DIR:  .../crypto_bot/scripts (è…³æœ¬æ‰€åœ¨ä½ç½®)
# PROJECT_ROOT: .../crypto_bot (å°ˆæ¡ˆæ ¹ç›®éŒ„)
CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(CURRENT_DIR)

# é è¨­å¿½ç•¥æ¸…å–®
# æ³¨æ„ï¼šæˆ‘å€‘ä¾ç„¶å¿½ç•¥ scripts è³‡æ–™å¤¾çš„æƒæï¼Œé¿å…æŠŠè…³æœ¬è‡ªå·±ä¹Ÿå¯«é€²å» context
DEFAULT_IGNORE_DIRS = {
    '.git', '.venv', 'venv', '__pycache__', 
    '.idea', '.vscode', 'node_modules', 'logs'
}

DEFAULT_IGNORE_FILES = {
    'project_context.txt', '.DS_Store', 'poetry.lock', 'package-lock.json', '*.pyc'
}

ALLOWED_EXTENSIONS = {
    '.py', '.json', '.md', '.txt', '.yml', '.yaml', 
    '.html', '.css', '.js', '.ini'
}

def load_gitignore_patterns(root_dir):
    """è®€å– .gitignore"""
    gitignore_path = os.path.join(root_dir, '.gitignore')
    patterns = set()
    
    if os.path.exists(gitignore_path):
        try:
            with open(gitignore_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        patterns.add(line.rstrip('/'))
        except Exception as e:
            print(f"âš ï¸ ç„¡æ³•è®€å– .gitignore: {e}")
            
    return patterns

def is_ignored(path, root_dir, ignore_dirs, ignore_files, gitignore_patterns):
    """æª¢æŸ¥æ˜¯å¦å¿½ç•¥"""
    name = os.path.basename(path)
    
    if name in ignore_dirs or name in ignore_files:
        return True
    
    rel_path = os.path.relpath(path, root_dir)
    rel_path_unix = rel_path.replace(os.sep, '/')
    
    for pattern in gitignore_patterns:
        if fnmatch.fnmatch(name, pattern):
            return True
        if fnmatch.fnmatch(rel_path_unix, pattern):
            return True
        if pattern in rel_path_unix.split('/'):
             return True

    return False

def generate_project_context(output_filename="project_context.txt"):
    # ğŸ”¥ ä¿®æ”¹é€™è£¡ï¼šå°‡è¼¸å‡ºè·¯å¾‘æ”¹ç‚º CURRENT_DIR (scripts è³‡æ–™å¤¾)
    output_file = os.path.join(CURRENT_DIR, output_filename)
    
    gitignore_patterns = load_gitignore_patterns(PROJECT_ROOT)
    
    print(f"ğŸ“‚ æƒæç›®æ¨™: {PROJECT_ROOT}")
    print(f"ğŸ“„ è¼¸å‡ºä½ç½®: {output_file}")

    with open(output_file, 'w', encoding='utf-8') as outfile:
        # 1. ç›®éŒ„çµæ§‹
        outfile.write("=== PROJECT STRUCTURE ===\n")
        for dirpath, dirnames, filenames in os.walk(PROJECT_ROOT):
            dirnames[:] = [d for d in dirnames if not is_ignored(os.path.join(dirpath, d), PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns)]
            
            level = dirpath.replace(PROJECT_ROOT, '').count(os.sep)
            indent = ' ' * 4 * level
            outfile.write(f"{indent}{os.path.basename(dirpath)}/\n")
            
            subindent = ' ' * 4 * (level + 1)
            for f in filenames:
                if not is_ignored(os.path.join(dirpath, f), PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns):
                    outfile.write(f"{subindent}{f}\n")
        
        outfile.write("\n" + "="*50 + "\n\n")

        # 2. æª”æ¡ˆå…§å®¹
        outfile.write("=== FILE CONTENTS ===\n")
        file_count = 0
        for dirpath, dirnames, filenames in os.walk(PROJECT_ROOT):
            dirnames[:] = [d for d in dirnames if not is_ignored(os.path.join(dirpath, d), PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns)]
            
            for filename in filenames:
                filepath = os.path.join(dirpath, filename)
                
                if is_ignored(filepath, PROJECT_ROOT, DEFAULT_IGNORE_DIRS, DEFAULT_IGNORE_FILES, gitignore_patterns):
                    continue
                
                ext = os.path.splitext(filename)[1]
                if ext not in ALLOWED_EXTENSIONS and filename != 'requirements.txt':
                    continue

                rel_path = os.path.relpath(filepath, PROJECT_ROOT)
                
                try:
                    with open(filepath, 'r', encoding='utf-8') as infile:
                        content = infile.read()
                        
                    outfile.write(f"\n--- START OF FILE: {rel_path} ---\n")
                    outfile.write(content)
                    outfile.write(f"\n--- END OF FILE: {rel_path} ---\n")
                    file_count += 1
                except Exception as e:
                    print(f"âš ï¸ ç„¡æ³•è®€å–æª”æ¡ˆ {rel_path}: {e}")

    print(f"âœ… åŒ¯å‡ºå®Œæˆï¼æª”æ¡ˆä½æ–¼ scripts è³‡æ–™å¤¾å…§ã€‚")

if __name__ == "__main__":
    generate_project_context()
--- END OF FILE: scripts\export_context.py ---

--- START OF FILE: services\email_service.py ---
#services/email_service.py
import sys
import os

# å–å¾—ç›®å‰æª”æ¡ˆæ‰€åœ¨çš„è³‡æ–™å¤¾ (services)
current_dir = os.path.dirname(os.path.abspath(__file__))
# å–å¾—ä¸Šä¸€å±¤è³‡æ–™å¤¾ (crypto_bot æ ¹ç›®éŒ„)
parent_dir = os.path.dirname(current_dir)
# å°‡æ ¹ç›®éŒ„åŠ å…¥ Python æœå°‹è·¯å¾‘
sys.path.append(parent_dir)

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.header import Header
from email.utils import formataddr  # ğŸ”¥ æ–°å¢é€™å€‹å¼•å…¥
import config

class EmailService:
    def __init__(self):
        self.smtp_server = config.SMTP_SERVER
        self.smtp_port = config.SMTP_PORT
        self.username = config.SMTP_USERNAME
        self.password = config.SMTP_PASSWORD
        self.to_addr = config.SMTP_TO_EMAIL  # é è¨­æ”¶ä»¶äºº

    def send_report(self, subject: str, html_content: str, to_email: str = None) -> bool:
        """
        ç™¼é€ HTML æ ¼å¼çš„éƒµä»¶ (è‡ªå‹•åŠ ä¸Š Crypto Bot æ¨™é ­èˆ‡å¯„ä»¶äººåç¨±)
        :param subject: éƒµä»¶æ¨™é¡Œ
        :param html_content: HTML å…§å®¹
        :param to_email: æ”¶ä»¶äºº (è‹¥æœªæŒ‡å®šå‰‡ä½¿ç”¨ config é è¨­å€¼)
        :return: æ˜¯å¦ç™¼é€æˆåŠŸ
        """
        # å¦‚æœ config æ²’è¨­å®šé–‹å•Ÿéƒµä»¶ï¼Œç›´æ¥è·³é (æ–¹ä¾¿æ¸¬è©¦)
        if not getattr(config, 'ENABLE_EMAIL', True):
            print(f"ğŸ”• Email åŠŸèƒ½å·²é—œé–‰ï¼Œè·³éç™¼é€: {subject}")
            return True

        target_email = to_email if to_email else self.to_addr

        # å»ºç«‹éƒµä»¶ç‰©ä»¶
        msg = MIMEMultipart()
        
        # ğŸ”¥ ä¿®æ”¹é€™è£¡ï¼šè®“æ”¶ä»¶äººçœ‹åˆ° "Crypto Bot" è€Œä¸æ˜¯åªæœ‰ Email
        msg['From'] = formataddr(("Crypto Bot", self.username))
        
        msg['To'] = target_email
        msg['Subject'] = Header(subject, 'utf-8')

        # çµ„åˆçµ±ä¸€çš„ HTML æ¨£æ¿
        full_html = f"""
        <html>
            <body style="font-family: Arial, sans-serif; color: #333;">
                <div style="border-bottom: 2px solid #0d6efd; padding-bottom: 10px; margin-bottom: 20px;">
                    <h2 style="margin: 0; color: #0d6efd;">ğŸ¤– Crypto Bot</h2>
                </div>

                <div style="line-height: 1.6;">
                    {html_content}
                </div>

                <hr style="border: 0; border-top: 1px solid #eee; margin: 30px 0 10px 0;">
                <p style="color: #999; font-size: 12px; margin: 0;">
                    æ­¤éƒµä»¶ç”± Python äº¤æ˜“æ©Ÿå™¨äººè‡ªå‹•ç™¼é€ã€‚<br>
                    æ™‚é–“: {config.TRADE_TIMEFRAME} ç­–ç•¥ç›£æ§ä¸­
                </p>
            </body>
        </html>
        """

        # åŠ å…¥ HTML å…§æ–‡
        msg.attach(MIMEText(full_html, 'html', 'utf-8'))

        try:
            # å»ºç«‹ SMTP é€£ç·š
            # å¦‚æœæ˜¯ Gmail æˆ–æ˜¯ä½¿ç”¨ SSL (Port 465)
            if self.smtp_port == 465:
                server = smtplib.SMTP_SSL(self.smtp_server, self.smtp_port)
            else:
                # å¦‚æœæ˜¯ TLS (Port 587)
                server = smtplib.SMTP(self.smtp_server, self.smtp_port)
                server.starttls()

            server.login(self.username, self.password)
            server.send_message(msg)
            server.quit()
            
            print(f"ğŸ“¨ Email ç™¼é€æˆåŠŸ: {subject} -> {target_email}")
            return True

        except Exception as e:
            print(f"âŒ Email ç™¼é€å¤±æ•—: {e}")
            return False

# ç”¨æ³•æ¸¬è©¦
if __name__ == "__main__":
    email_service = EmailService()
    email_service.send_report("åç¨±é¡¯ç¤ºæ¸¬è©¦", "<p>æ‚¨æ‡‰è©²æœƒçœ‹åˆ°å¯„ä»¶äººæ˜¯ <b>Crypto Bot</b>ã€‚</p>")
--- END OF FILE: services\email_service.py ---

--- START OF FILE: services\market_data_service.py ---
# services/market_data_service.py
import sys
import os
import pandas as pd
import pandas_ta as ta
from datetime import datetime
from typing import Dict, Any, Optional

# ğŸ”¥ å–å¾—ç›®å‰æª”æ¡ˆçš„è·¯å¾‘ï¼Œä¸¦å°‡ã€Œä¸Šä¸€å±¤ç›®éŒ„ã€åŠ å…¥ Python æœå°‹è·¯å¾‘
# é€™æ¨£æ‰èƒ½æ­£ç¢ºå¼•å…¥ config å’Œ utils
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

import config
from utils.zigzag import ZigZagIdentifier  # ğŸ”¥ å¼•å…¥ ZigZag å·¥å…·

class MarketDataService:
    def __init__(self):
        # --- 1. åŸºç¤è¨­å®šåƒæ•¸ (å¾ config è®€å–) ---
        
        # A. è¶¨å‹¢ (Trend)
        self.ma_fast = getattr(config, 'SMA_SHORT', 7)
        self.ma_slow = getattr(config, 'SMA_LONG', 25)
        self.bb_length = 20
        self.bb_std = 2.0
        
        # MACD
        self.macd_fast = 12
        self.macd_slow = 26
        self.macd_signal = 9
        
        # B. å‹•èƒ½ (Momentum)
        self.rsi_length = 14
        self.kdj_length = getattr(config, 'KDJ_LENGTH', 9)
        self.kdj_signal = getattr(config, 'KDJ_SIGNAL', 3)
        
        # C. æ³¢å‹•ç‡ (Volatility)
        self.atr_length = 14
        
        # D. æˆäº¤é‡ (Volume)
        self.mfi_length = 14
        
        # E. ğŸ”¥ çµæ§‹ (Structure / ZigZag)
        self.zigzag_order = getattr(config, 'ZIGZAG_ORDER', 5)
        # åˆå§‹åŒ– ZigZag è­˜åˆ¥å™¨
        self.zigzag = ZigZagIdentifier(order=self.zigzag_order)

    def _safe_get_value(self, series: pd.Series, default: float = 0.0) -> float:
        """å®‰å…¨å–å¾— Series æœ€å¾Œä¸€å€‹å€¼ï¼Œè‹¥ç‚º NaN æˆ– None å‰‡å›å‚³ default"""
        if series is None or series.empty:
            return default
        val = series.iloc[-1]
        return val if pd.notna(val) else default

    def analyze_technicals(self, df: pd.DataFrame) -> Dict[str, Any]:
        """
        è¨ˆç®—æŠ€è¡“æŒ‡æ¨™ä¸¦è¿”å›çµæ§‹åŒ–æ•¸æ“šèˆ‡æ–‡å­—æè¿°
        :param df: åŒ…å« Open, High, Low, Close, Volume çš„ DataFrame
        :return: åŒ…å«æ•¸å€¼èˆ‡æ–‡å­—æ‘˜è¦çš„å­—å…¸
        """
        # 1. åŸºç¤è³‡æ–™æª¢æŸ¥
        if df is None or df.empty:
            print("âš ï¸ è­¦å‘Š: å‚³å…¥çš„ DataFrame ç‚ºç©º")
            return {}
        
        # ç¢ºä¿è³‡æ–™é•·åº¦è¶³å¤ è¨ˆç®—é•·å¤©æœŸæŒ‡æ¨™ (è‡³å°‘è¦æ¯” ma_slow é•·)
        min_required_len = max(self.ma_slow, self.macd_slow, 30)
        if len(df) < min_required_len:
            print(f"âš ï¸ è­¦å‘Š: æ•¸æ“šé•·åº¦ä¸è¶³ ({len(df)} < {min_required_len})ï¼ŒæŒ‡æ¨™å¯èƒ½ä¸æº–ç¢º")

        # è¤‡è£½ä¸¦è™•ç†ç´¢å¼• (VWAP éœ€è¦æ™‚é–“ç´¢å¼•)
        df = df.copy()
        if 'timestamp' in df.columns:
            df['timestamp'] = pd.to_datetime(df['timestamp'])
            df.set_index('timestamp', inplace=True)

        # ==========================================
        # 2. è¨ˆç®—æŒ‡æ¨™ (ä½¿ç”¨ pandas_ta æ“´å……æ–¹æ³•)
        # ==========================================
        try:
            # --- A. è¶¨å‹¢èˆ‡æ³¢æ®µ ---
            df['ma_fast'] = ta.sma(df['close'], length=self.ma_fast)
            df['ma_slow'] = ta.sma(df['close'], length=self.ma_slow)
            
            # BBands
            bbands = ta.bbands(df['close'], length=self.bb_length, std=self.bb_std)
            if bbands is not None:
                df['bb_lower'] = bbands.iloc[:, 0]
                df['bb_upper'] = bbands.iloc[:, 2]
            else:
                df['bb_lower'], df['bb_upper'] = df['close'], df['close']

            # MACD
            macd = ta.macd(df['close'], fast=self.macd_fast, slow=self.macd_slow, signal=self.macd_signal)
            if macd is not None:
                df['macd_line'] = macd.iloc[:, 0]   # DIF
                df['macd_hist'] = macd.iloc[:, 1]   # Histogram
                df['macd_signal'] = macd.iloc[:, 2] # Signal
            else:
                df['macd_line'], df['macd_hist'], df['macd_signal'] = 0, 0, 0

            # --- B. å‹•èƒ½ ---
            df['rsi'] = ta.rsi(df['close'], length=self.rsi_length)
            
            # KDJ
            kdj = ta.kdj(df['high'], df['low'], df['close'], length=self.kdj_length, signal=self.kdj_signal)
            if kdj is not None:
                df['kdj_k'] = kdj.iloc[:, 0]
                df['kdj_d'] = kdj.iloc[:, 1]
                df['kdj_j'] = kdj.iloc[:, 2]
            else:
                df['kdj_k'], df['kdj_d'], df['kdj_j'] = 50, 50, 50

            # --- C. æ³¢å‹•ç‡ ---
            df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=self.atr_length)

            # --- D. æˆäº¤é‡æŒ‡æ¨™ ---
            df['obv'] = ta.obv(df['close'], df['volume'])
            df['mfi'] = ta.mfi(df['high'], df['low'], df['close'], df['volume'], length=self.mfi_length)
            
            # VWAP (éœ€è¦ Exception Handling å› ç‚ºä¾è³´æ™‚é–“ç´¢å¼•)
            try:
                vwap = ta.vwap(df['high'], df['low'], df['close'], df['volume'])
                df['vwap'] = vwap if vwap is not None else df['ma_slow']
            except Exception:
                # è‹¥è¨ˆç®—å¤±æ•— (ä¾‹å¦‚ index ä¸æ˜¯ datetime)ï¼Œé™ç´šä½¿ç”¨ MA æˆ– Close
                df['vwap'] = df['ma_slow'] if 'ma_slow' in df else df['close']

        except Exception as e:
            print(f"âŒ æŒ‡æ¨™è¨ˆç®—ç™¼ç”ŸéŒ¯èª¤: {e}")
            # ç™¼ç”Ÿåš´é‡éŒ¯èª¤æ™‚ï¼Œç›´æ¥å›å‚³ç©ºå­—å…¸æˆ–é€²è¡Œé™ç´šè™•ç†
            return {}

        # ==========================================
        # 3. æ•¸æ“šæ¸…ç†èˆ‡å–å€¼
        # ==========================================
        # ä½¿ç”¨ ffill å¡«è£œ NaN (å‰ç«¯è¨ˆç®—æŒ‡æ¨™å¸¸æœ‰ NaN)
        df = df.ffill().fillna(0)
        
        # å–å¾—æœ€å¾Œä¸€ç­†æ•¸æ“š
        row = df.iloc[-1]
        prev_row = df.iloc[-2] if len(df) > 1 else row
        
        # å–å€¼ Helper (è½‰ç‚º float é¿å… numpy type å•é¡Œ)
        close = float(row['close'])
        ma_fast = float(row['ma_fast'])
        ma_slow = float(row['ma_slow'])
        
        # --- è¶¨å‹¢åˆ¤æ–· ---
        if ma_fast > ma_slow:
            trend = "å¤šé ­æ’åˆ— (Bullish)"
            trend_signal = "LONG"
        else:
            trend = "ç©ºé ­æ’åˆ— (Bearish)"
            trend_signal = "SHORT"

        # --- BBands ---
        bb_upper = float(row['bb_upper'])
        bb_lower = float(row['bb_lower'])
        bb_pos = "ä¸­è»¸éœ‡ç›ª"
        if close >= bb_upper: bb_pos = "è§¸åŠä¸Šè»Œ (å£“åŠ›/è¶…è²·)"
        elif close <= bb_lower: bb_pos = "è§¸åŠä¸‹è»Œ (æ”¯æ’/è¶…è³£)"

        # --- KDJ ---
        k_val = float(row['kdj_k'])
        d_val = float(row['kdj_d'])
        j_val = float(row['kdj_j'])
        
        kdj_cross = "K>D (é‡‘å‰å‚¾å‘)" if k_val > d_val else "K<D (æ­»å‰å‚¾å‘)"
        kdj_status = "æ­£å¸¸"
        if j_val > 100: kdj_status = "Jç·šè¶…è²· (>100)"
        elif j_val < 0: kdj_status = "Jç·šè¶…è³£ (<0)"

        # --- é¢¨æ§ (ATR) ---
        atr_val = float(row['atr'])
        if atr_val <= 0: atr_val = close * 0.01 # é˜²å‘†
        
        atr_stop_loss = atr_val * 2
        sl_long = close - atr_stop_loss
        sl_short = close + atr_stop_loss
        risk_pct = (atr_stop_loss / close) * 100

        # --- æˆäº¤é‡ (VWAP/MFI/OBV) ---
        vwap_val = float(row['vwap'])
        if vwap_val == 0: vwap_val = close
        
        vwap_status = "åƒ¹æ ¼ > VWAP (å¼·å‹¢)" if close > vwap_val else "åƒ¹æ ¼ < VWAP (å¼±å‹¢)"
        
        mfi_val = float(row['mfi'])
        mfi_status = "ä¸­æ€§"
        if mfi_val > 80: mfi_status = "è³‡é‡‘éç†± (è¶…è²· >80)"
        elif mfi_val < 20: mfi_status = "è³‡é‡‘å†·å» (è¶…è³£ <20)"
        
        obv_val = float(row['obv'])
        prev_obv = float(prev_row['obv'])
        obv_trend = "OBVä¸Šå‡ (è³‡é‡‘æµå…¥)" if obv_val > prev_obv else "OBVä¸‹é™ (è³‡é‡‘æµå‡º)"

        # ==========================================
        # ğŸ”¥ 4. ZigZag çµæ§‹åˆ†æ
        # ==========================================
        # å–å¾—æœ€è¿‘ 5 å€‹è½‰æŠ˜é» (ç”¨ä¾†åˆ¤æ–· XABCD)
        try:
            last_pivots = self.zigzag.get_last_n_pivots(df, n=5)
        except Exception as e:
            print(f"âš ï¸ ZigZag è¨ˆç®—å¤±æ•—: {e}")
            last_pivots = []
        
        # è½‰æˆæ–‡å­—æè¿°çµ¦ AI
        zigzag_text = "å°šç„¡è¶³å¤ è½‰æŠ˜é»"
        if len(last_pivots) >= 3:
            zigzag_text = "æœ€è¿‘è½‰æŠ˜é» (èˆŠ->æ–°):\n"
            for p in last_pivots:
                # ç°¡å–®å–æ™‚é–“ HH:MM
                p_time = str(p['time']).split(' ')[-1][:5] if ' ' in str(p['time']) else str(p['time'])
                zigzag_text += f"        - {p['type']} @ {p['price']:.2f} ({p_time})\n"

        # ==========================================
        # 5. ç”Ÿæˆ Prompt
        # ==========================================
        ta_text = f"""
        ã€æœ€æ–°åƒ¹æ ¼æ•¸æ“šã€‘
        - ç¾åƒ¹: {close:.2f}
        
        ã€è¶¨å‹¢æŒ‡æ¨™ (Trend)ã€‘
        - MAå‡ç·š: {trend} | MA{self.ma_fast}={ma_fast:.2f}, MA{self.ma_slow}={ma_slow:.2f}
        - MACDæŒ‡æ¨™: DIF={row['macd_line']:.2f}, DEM={row['macd_signal']:.2f}, æŸ±ç‹€åœ–={row['macd_hist']:.4f}
        
        ã€å¸‚å ´çµæ§‹ (Structure / ZigZag)ã€‘
        {zigzag_text}
        (è¨»: å¯ç”¨æ–¼åˆ¤æ–·è«§æ³¢å‹æ…‹ X-A-B-C-D æˆ–æ”¯æ’å£“åŠ›ä½)

        ã€æˆäº¤é‡åˆ†æ (Volume)ã€‘
        - VWAP (æ©Ÿæ§‹æˆæœ¬): {vwap_val:.2f} | ç‹€æ…‹: {vwap_status}
          (è¨»: æ—¥å…§äº¤æ˜“é‡è¦æ”¯æ’å£“åŠ›ï¼Œåƒ¹æ ¼åœ¨ VWAP ä¹‹ä¸Šåå¤šï¼Œä¹‹ä¸‹åç©º)
        - OBV (èƒ½é‡æ½®): {obv_val:.0f} | è¶¨å‹¢: {obv_trend}
        - MFI (è³‡é‡‘æµå‘): {mfi_val:.1f} | ç‹€æ…‹: {mfi_status} (å«é‡çš„RSIï¼Œ>80è¶…è²· <20è¶…è³£)
        
        ã€å‹•èƒ½èˆ‡éœ‡ç›ª (Momentum)ã€‘
        - RSI({self.rsi_length}): {row['rsi']:.1f}
        - KDJæŒ‡æ¨™: K={k_val:.1f}, D={d_val:.1f}, J={j_val:.1f} | {kdj_status}
        - å¸ƒæ—å¸¶: {bb_pos} (ä¸Šè»Œ:{bb_upper:.2f} / ä¸‹è»Œ:{bb_lower:.2f})
        
        ã€æ³¢å‹•ç‡èˆ‡é¢¨æ§ (Volatility)ã€‘
        - ATR({self.atr_length}): {atr_val:.4f}
        - [å¤šå–®] æ­¢æåƒ¹: {sl_long:.2f} | åƒ¹å·®: -{atr_stop_loss:.2f} (é¢¨éšª: -{risk_pct:.2f}%)
        - [ç©ºå–®] æ­¢æåƒ¹: {sl_short:.2f} | åƒ¹å·®: +{atr_stop_loss:.2f} (é¢¨éšª: -{risk_pct:.2f}%)
        """

        # ==========================================
        # 6. è¿”å›çµæœ
        # ==========================================
        return {
            "close": close,
            "rsi": float(row['rsi']),
            "kdj_k": k_val,
            "kdj_j": j_val,
            
            "ma_fast": float(row['ma_fast']),
            "ma_slow": float(row['ma_slow']),
            
            "macd_hist": float(row['macd_hist']),
            "atr": atr_val,
            "obv": obv_val,
            "mfi": mfi_val,
            "vwap": vwap_val,
            "trend": trend,
            "trend_signal": trend_signal,
            "pivots": last_pivots, 
            "technical_analysis_text": ta_text, 
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }

if __name__ == "__main__":
    # ... (æ¸¬è©¦å€å¡Šä¿æŒä¸è®Š) ...
    import numpy as np
    print("ğŸ¤– å•Ÿå‹• MarketDataService æ¸¬è©¦ç¨‹åº...")
    periods = 200 # å¢åŠ æ•¸æ“šé•·åº¦ä»¥ä¾¿ ZigZag è¨ˆç®—
    dates = pd.date_range(end=datetime.now(), periods=periods, freq='15min')
    np.random.seed(42)
    price_changes = np.random.randn(periods) * 10 
    close_prices = np.cumsum(price_changes) + 3000
    data = {
        'timestamp': dates,
        'open': close_prices + np.random.randint(-5, 5, periods),
        'high': close_prices + np.random.randint(5, 15, periods),
        'low': close_prices - np.random.randint(5, 15, periods),
        'close': close_prices,
        'volume': np.abs(np.random.randn(periods) * 100) + 50
    }
    df_test = pd.DataFrame(data)
    service = MarketDataService()
    try:
        print("ğŸ” æ­£åœ¨è¨ˆç®—æŠ€è¡“æŒ‡æ¨™...")
        result = service.analyze_technicals(df_test)
        if result:
            print("\nâœ… è¨ˆç®—æˆåŠŸï¼")
            pivots = result.get('pivots', [])
            print(f"ğŸ“Š æŠ“åˆ° {len(pivots)} å€‹è½‰æŠ˜é»")
            print(f"ğŸ› ï¸ æ•¸å€¼æª¢æŸ¥: VWAP={result['vwap']:.2f}")
    except Exception as e:
        print(f"âŒ ç™¼ç”ŸéŒ¯èª¤: {e}")
--- END OF FILE: services\market_data_service.py ---

--- START OF FILE: services\qa_service.py ---
# services/qa_service.py
import json
import os
import config
from datetime import datetime
from typing import List, Dict, Any

class QAService:
    def __init__(self, filename: str = "questions.json"):
        self.filename = filename

    def _load_questions(self) -> List[Dict[str, Any]]:
        """è®€å–å•é¡Œåˆ—è¡¨"""
        if not os.path.exists(self.filename):
            default_data = [{"id": "example01", "question": "ç¯„ä¾‹: ETHèµ°å‹¢åˆ†æ", "answered": False, "frequency": 3600}]
            self._save_questions(default_data)
            return default_data
        
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"âš ï¸ è®€å–å•é¡Œæª”å¤±æ•—: {e}")
            return []

    def _save_questions(self, data: List[Dict[str, Any]]) -> None:
        """å„²å­˜å•é¡Œåˆ—è¡¨"""
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

    def _format_email_content(self, q_id: str, question: str, answer_html: str) -> str:
        """ç”Ÿæˆ Email çš„ HTML å…§å®¹"""
        return f"""
        <div style="background-color: #f8f9fa; padding: 15px; border-left: 5px solid #0d6efd; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; color: #0d6efd;">ğŸ“Œ æå•ç·¨è™Ÿ: {q_id}</h3>
            <p style="font-size: 16px; font-weight: bold; margin: 0; line-height: 1.5;">
                {question}
            </p>
        </div>
        
        <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">
        
        <div style="font-family: Arial, sans-serif; line-height: 1.6;">
            {answer_html}
        </div>
        """

    def mark_as_answered(self, question_id: str) -> None:
        """æ›´æ–°å•é¡Œç‹€æ…‹ (æ›´æ–°æœ€å¾Œå›ç­”æ™‚é–“)"""
        questions = self._load_questions()
        updated = False
        
        for q in questions:
            if q.get('id') == question_id:
                q['answered'] = True
                q['answered_at'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                updated = True
                break
        
        if updated:
            self._save_questions(questions)

    def process_pending_questions(self, ai_reporter, mailer) -> None:
        """
        æ ¸å¿ƒé‚è¼¯ï¼šè™•ç†æœªå›ç­” æˆ– é€±æœŸæ€§éœ€é‡å• çš„å•é¡Œ
        """
        if not getattr(config, 'ENABLE_QA_SYSTEM', False):
            return

        questions = self._load_questions()
        pending_count = 0

        for q in questions:
            q_id = q.get('id', 'unknown')
            q_text = q.get('question', '')
            is_answered = q.get('answered', False)
            frequency = q.get('frequency', 0) # é è¨­ 0 (ä¸é‡è¤‡)
            
            should_process = False

            # --- åˆ¤æ–·é‚è¼¯ ---
            # æƒ…æ³ 1: å¾æœªå›ç­”é -> åŸ·è¡Œ
            if not is_answered:
                should_process = True
            
            # æƒ…æ³ 2: æ˜¯é€±æœŸæ€§å•é¡Œ (frequency > 0) -> æª¢æŸ¥æ™‚é–“å·®
            elif frequency > 0:
                last_time_str = q.get('answered_at')
                if last_time_str:
                    try:
                        last_time = datetime.strptime(last_time_str, "%Y-%m-%d %H:%M:%S")
                        # è¨ˆç®—è·é›¢ä¸Šæ¬¡å›ç­”éäº†å¥½å¹¾ç§’
                        seconds_diff = (datetime.now() - last_time).total_seconds()
                        
                        if seconds_diff >= frequency:
                            print(f"â° é€±æœŸæ€§å•é¡Œ {q_id} æ™‚é–“åˆ° (è·ä¸Šæ¬¡ {int(seconds_diff)} ç§’) -> æº–å‚™åŸ·è¡Œ")
                            should_process = True
                    except Exception as e:
                        print(f"âš ï¸ æ™‚é–“æ ¼å¼è§£æéŒ¯èª¤ ({q_id}): {e}ï¼Œå°‡é‡ç½®ç‚ºå¯åŸ·è¡Œ")
                        should_process = True
            
            # --- åŸ·è¡Œå•ç­” ---
            if should_process:
                print(f"\nğŸ’¡ è™•ç†å•é¡Œ ({q_id}): {q_text}")
                print("ğŸ¤– AI æ­£åœ¨æ€è€ƒç­”æ¡ˆ...")

                try:
                    # 1. AI ç”Ÿæˆç­”æ¡ˆ
                    answer_html = ai_reporter.generate_free_qa(q_text)
                    
                    # 2. çµ„åˆ Email
                    # å¦‚æœæ˜¯é€±æœŸæ€§å•é¡Œï¼Œæ¨™é¡Œå¯ä»¥åŠ è¨»æ™‚é–“ï¼Œæ–¹ä¾¿å€åˆ†
                    title_prefix = "ğŸ”„ [å®šæœŸ] " if frequency > 0 else "ğŸ§  "
                    email_subject = f"{title_prefix}AI å•ç­”å›è¦†: {q_id}"
                    
                    email_body = self._format_email_content(q_id, q_text, answer_html)

                    # 3. ç™¼é€éƒµä»¶
                    mailer.send_report(email_subject, email_body)
                    print(f"ğŸ“¨ å›è¦†å·²å¯„å‡º: {q_id}")

                    # 4. æ›´æ–°ç‹€æ…‹ (å¯«å…¥å›ç­”æ™‚é–“)
                    self.mark_as_answered(q_id)
                    pending_count += 1

                except Exception as e:
                    print(f"âŒ è™•ç†å•é¡Œ {q_id} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

        if pending_count > 0:
            print(f"âœ… æœ¬æ¬¡å…±è™•ç†äº† {pending_count} å€‹å•é¡Œ")
--- END OF FILE: services\qa_service.py ---

--- START OF FILE: services\report_service.py ---
import google.generativeai as genai
import config
from typing import Dict, Any

class ReportService:
    def __init__(self):
        # è¨­å®š Gemini API
        # å³ä½¿æ˜¯æ¸¬è©¦æ¨¡å¼ï¼Œåˆå§‹åŒ–é€šå¸¸é‚„æ˜¯ç•™è‘—ï¼Œä»¥å…çªç„¶åˆ‡æ›é–‹é—œæ™‚å ±éŒ¯
        try:
            genai.configure(api_key=config.GEMINI_API_KEY)
            self.model = genai.GenerativeModel(config.GEMINI_MODEL_NAME)
        except Exception as e:
            print(f"âš ï¸ Gemini åˆå§‹åŒ–è­¦å‘Š: {e}")

    def _generate_html(self, prompt: str) -> str:
        """å…§éƒ¨æ–¹æ³•ï¼šå‘¼å« AI ä¸¦æ¸…ç†è¼¸å‡º"""
        try:
            print("ğŸ¤– æ­£åœ¨å‘¼å« Gemini ç”Ÿæˆå…§å®¹...")
            response = self.model.generate_content(prompt)
            return response.text.replace("```html", "").replace("```", "").strip()
        except Exception as e:
            print(f"âŒ AI å ±å‘Šç”Ÿæˆå¤±æ•—: {e}")
            return "<p>âš ï¸ å ±å‘Šç”Ÿæˆç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚</p>"

    def generate_entry_report(self, context: Dict[str, Any]) -> str:
        """ç”Ÿæˆäº¤æ˜“é€²å ´å ±å‘Š"""
        
        # å‹•æ…‹æ±ºå®šèƒŒæ™¯è‰²
        bg_color = '#e6f4ea' if 'LONG' in context.get('trend_signal', '') else '#fce8e6'

        # ğŸ”¥ 1. æª¢æŸ¥æ˜¯å¦å•Ÿç”¨ AI
        if not getattr(config, 'ENABLE_AI_GENERATION', True):
            print("ğŸ§ª [æ¸¬è©¦æ¨¡å¼] è·³é AI ç”Ÿæˆï¼Œä½¿ç”¨éœæ…‹æ¨£æ¿ã€‚")
            return f"""
            <div style="background-color: {bg_color}; padding: 15px; border-radius: 5px;">
                <h3 style="margin-top: 0;">[æ¸¬è©¦æ¨¡å¼] äº¤æ˜“è¨Šè™Ÿ: {context.get('symbol')}</h3>
                <p><strong>å‹•ä½œ:</strong> {context.get('action')} (åƒ¹æ ¼: {context.get('price')})</p>
                <hr>
                <h4>æŠ€è¡“æ•¸æ“šæ‘˜è¦ (ç„¡ AI åˆ†æ)</h4>
                <pre style="background: #f0f0f0; padding: 10px;">{context.get('technical_analysis_text')}</pre>
                <p><em>è¨»ï¼šæ­¤ç‚º Mock è³‡æ–™ï¼Œæœªæ¶ˆè€— AI Tokenã€‚</em></p>
            </div>
            """

        # ğŸ”¥ 2. çœŸå¯¦ AI é‚è¼¯
        prompt = f"""
        ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„é‡åŒ–äº¤æ˜“åŠ©ç†ã€‚è«‹æ ¹æ“šä»¥ä¸‹æ•¸æ“šå¯«ä¸€ä»½ **HTML äº¤æ˜“å¿«è¨Š**ã€‚
        
        ã€äº¤æ˜“è³‡è¨Šã€‘
        - æ¨™çš„: {context.get('symbol')}
        - è¨Šè™Ÿ: {context.get('trend_signal')}
        - ç¾åƒ¹: {context.get('close')}
        - æ™‚é–“: {context.get('time')}
        
        ã€æŠ€è¡“æŒ‡æ¨™æ•¸æ“šã€‘
        {context.get('technical_analysis_text')}
        
        ã€è¼¸å‡ºè¦æ±‚ã€‘
        1. HTML æ ¼å¼ï¼ŒèƒŒæ™¯è‰²ä½¿ç”¨ {bg_color}ã€‚
        2. æ¨™é¡Œ: äº¤æ˜“è¨Šè™Ÿ ({context.get('symbol')} {context.get('trend_signal')})ã€‚
        3. ç”¨è¡¨æ ¼å‘ˆç¾æŠ€è¡“æŒ‡æ¨™æ•¸æ“šã€‚
        4. æ ¹æ“šæ•¸æ“šç°¡çŸ­åˆ†æé€²å ´ç†ç”±ã€‚
        5. çµ¦å‡ºæ­¢æ/æ­¢ç›ˆå»ºè­°ã€‚
        6. åªè¼¸å‡º HTML ä»£ç¢¼ï¼Œä¸è¦æœ‰ Markdownã€‚
        """
        return self._generate_html(prompt)

    def generate_market_report(self, context: Dict[str, Any]) -> str:
        """ç”Ÿæˆå®šæœŸå¸‚å ´é€±å ±"""

        # ğŸ”¥ 1. æª¢æŸ¥æ˜¯å¦å•Ÿç”¨ AI
        if not getattr(config, 'ENABLE_AI_GENERATION', True):
            print("ğŸ§ª [æ¸¬è©¦æ¨¡å¼] è·³é AI ç”Ÿæˆï¼Œä½¿ç”¨éœæ…‹æ¨£æ¿ã€‚")
            return f"""
            <div style="background-color: #e8f0fe; padding: 15px; border-radius: 5px;">
                <h3 style="margin-top: 0;">[æ¸¬è©¦æ¨¡å¼] å¸‚å ´é€±å ±: {context.get('symbol')}</h3>
                <p><strong>æ™‚é–“:</strong> {context.get('time')}</p>
                <hr>
                <h4>æŠ€è¡“æ•¸æ“šæ‘˜è¦</h4>
                <pre style="background: #fff; padding: 10px;">{context.get('technical_analysis_text')}</pre>
                <p><em>è¨»ï¼šæ­¤ç‚º Mock è³‡æ–™ï¼Œæœªæ¶ˆè€— AI Tokenã€‚</em></p>
            </div>
            """

        # ğŸ”¥ 2. çœŸå¯¦ AI é‚è¼¯
        prompt = f"""
        ä½ æ˜¯ä¸€å€‹è³‡æ·±çš„åŠ å¯†è²¨å¹£åˆ†æå¸«ã€‚è«‹æ ¹æ“šä»¥ä¸‹æ•¸æ“šå¯«ä¸€ä»½ **HTML å¸‚å ´è¶¨å‹¢æ—¥å ±**ã€‚
        
        ã€å¸‚å ´è³‡è¨Šã€‘
        - æ¨™çš„: {context.get('symbol')}
        - å ±å‘Šæ™‚é–“: {context.get('time')}
        
        ã€æŠ€è¡“åˆ†ææ‘˜è¦ã€‘
        {context.get('technical_analysis_text')}
        
        ã€è¼¸å‡ºè¦æ±‚ã€‘
        1. é¢¨æ ¼å°ˆæ¥­ã€å®¢è§€ï¼Œæ¨™é¡ŒèƒŒæ™¯è‰²ä½¿ç”¨ #e8f0feã€‚
        2. **å¸‚å ´è§£è®€**: åˆ¤æ–·ç›®å‰æ˜¯å¤§è¶¨å‹¢å¤šé ­ã€ç©ºé ­é‚„æ˜¯ç›¤æ•´ã€‚
        3. **é—œéµé»ä½**: åˆ†ææ”¯æ’èˆ‡å£“åŠ›ã€‚
        4. **æ“ä½œå»ºè­°**: é‡å°ç©ºæ‰‹è€…èˆ‡æŒå€‰è€…çµ¦äºˆå»ºè­°ã€‚
        5. åªè¼¸å‡º HTML ä»£ç¢¼ã€‚
        """
        return self._generate_html(prompt)

    def generate_free_qa(self, user_question: str) -> str:
        """QA ç³»çµ±å°ˆç”¨ä»‹é¢"""

        # ğŸ”¥ 1. æª¢æŸ¥æ˜¯å¦å•Ÿç”¨ AI
        if not getattr(config, 'ENABLE_AI_GENERATION', True):
            print("ğŸ§ª [æ¸¬è©¦æ¨¡å¼] è·³é AI ç”Ÿæˆã€‚")
            return f"""
            <div style="border-left: 4px solid #999; padding-left: 10px;">
                <p><strong>[æ¸¬è©¦æ¨¡å¼å›è¦†]</strong></p>
                <p>æ‚¨å•äº†ï¼š<em>{user_question}</em></p>
                <p>ç›®å‰ AI ç”ŸæˆåŠŸèƒ½å·²é—œé–‰ï¼Œç„¡æ³•æä¾›è©³ç´°è§£ç­”ã€‚</p>
            </div>
            """

        # ğŸ”¥ 2. çœŸå¯¦ AI é‚è¼¯
        prompt = f"""
        ä½¿ç”¨è€…å•é¡Œ: {user_question}
        
        è«‹ä»¥ã€ŒåŠ å¯†è²¨å¹£èˆ‡é‡‘èäº¤æ˜“é¡§å•ã€çš„èº«åˆ†å›ç­”ï¼š
        1. ä½¿ç”¨ HTML æ ¼å¼ (ä¸å« ``` æ¨™è¨˜)ã€‚
        2. é‡é»åŠ ç²—ã€‚
        3. èªæ°£å°ˆæ¥­è¦ªåˆ‡ã€‚
        """
        return self._generate_html(prompt)
--- END OF FILE: services\report_service.py ---

--- START OF FILE: services\trading_service.py ---
import sys
import os

# ğŸ”¥ å–å¾—ç›®å‰æª”æ¡ˆçš„è·¯å¾‘ï¼Œä¸¦å°‡ã€Œä¸Šä¸€å±¤ç›®éŒ„ã€åŠ å…¥ Python æœå°‹è·¯å¾‘
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

# æ¥è‘—æ‰æ˜¯åŸæœ¬çš„ import
import config
from datetime import datetime
import time

# å¼•å…¥æ ¸å¿ƒå·¥å…·
from services.market_data_service import MarketDataService
from utils.data_loader import BingXLoader
from utils.executor import BingXExecutor
from utils.trade_logger import TradeLogger

# å¼•å…¥ç­–ç•¥å°ç…§è¡¨
from strategies import STRATEGY_MAP

class TradingService:
    def __init__(self, report_service=None, email_service=None):
        """
        æ•´åˆæ‰€æœ‰äº¤æ˜“ç›¸é—œçš„å…ƒä»¶ (æ”¯æ´å¤šç­–ç•¥)
        """
        self.report_service = report_service
        self.email_service = email_service
        
        self.market_data_service = MarketDataService()
        self.loader = BingXLoader()
        self.executor = BingXExecutor(self.loader.exchange)
        self.logger = TradeLogger()

        # åˆå§‹åŒ–å¤šç­–ç•¥ç³»çµ±
        self.strategies = []
        print(f"âš™ï¸ æ­£åœ¨è¼‰å…¥ç­–ç•¥: {config.ACTIVE_STRATEGIES}")
        
        for strategy_name in config.ACTIVE_STRATEGIES:
            strategy_class = STRATEGY_MAP.get(strategy_name)
            if strategy_class:
                self.strategies.append(strategy_class()) # å¯¦ä¾‹åŒ–ç­–ç•¥ç‰©ä»¶
            else:
                print(f"âš ï¸ è­¦å‘Š: æ‰¾ä¸åˆ°ç­–ç•¥ {strategy_name}ï¼Œè«‹æª¢æŸ¥æ‹¼å­—æˆ– __init__.py")

        self.symbols = config.COIN_LIST

    def _get_combined_signal(self, df, context):
        """
        ğŸ”¥ æ ¸å¿ƒï¼šæ•´åˆæ‰€æœ‰ç­–ç•¥çš„æŠ•ç¥¨çµæœ
        å›å‚³: (final_signal, concise_reason, detailed_logs)
        """
        final_signal = "NEUTRAL"
        final_reasons = [] # çµ¦ä¸‹å–®ç´€éŒ„ç”¨çš„ç°¡æ½”ç†ç”±
        detailed_logs = [] # ğŸ”¥ çµ¦ Log é¡¯ç¤ºç”¨çš„è©³ç´°æ¸…å–®
        
        long_votes = 0
        short_votes = 0
        
        for strategy in self.strategies:
            try:
                result = strategy.analyze(df, context)
                sig = result['signal']
                reason = result['reason']
                name = strategy.__class__.__name__
                
                # 1. æ”¶é›†è©³ç´° Log
                # æ ¼å¼: [ç­–ç•¥å] è¨Šè™Ÿ: ç†ç”±
                detailed_logs.append(f"[{name}] {sig}: {reason}")

                # 2. çµ±è¨ˆæŠ•ç¥¨
                if sig == "LONG":
                    long_votes += 1
                    final_reasons.append(f"[{name}] {reason}")
                elif sig == "SHORT":
                    short_votes += 1
                    final_reasons.append(f"[{name}] {reason}")
            except Exception as e:
                print(f"âŒ ç­–ç•¥ {strategy} åŸ·è¡ŒéŒ¯èª¤: {e}")
                detailed_logs.append(f"[{strategy.__class__.__name__}] ERROR: {e}")
        
        # --- æ±ºç­–é‚è¼¯ ---
        if long_votes > 0 and short_votes > 0:
            final_signal = "NEUTRAL"
            final_reasons = ["âš ï¸ ç­–ç•¥è¡çª (å¤šç©ºäº’æ–¥)ï¼Œç³»çµ±é¸æ“‡è§€æœ›"]
        elif long_votes > 0:
            final_signal = "LONG"
        elif short_votes > 0:
            final_signal = "SHORT"
            
        return final_signal, " | ".join(final_reasons), detailed_logs

    def run_cycle(self):
        """
        åŸ·è¡Œä¸€æ¬¡å®Œæ•´çš„äº¤æ˜“å¾ªç’°
        """
        print(f"ğŸ”¨ TradingService: é–‹å§‹æƒæå¸‚å ´ ({config.TRADE_TIMEFRAME})...")

        for symbol in self.symbols:
            try:
                # Step 1: ç²å–æ•¸æ“š
                df = self.loader.fetch_data(
                    timeframe=config.TRADE_TIMEFRAME, 
                    symbol=symbol, 
                    limit=200
                )
                
                if df is None or df.empty:
                    print(f"   âš ï¸ è·³é {symbol}: ç„¡æ³•ç²å–æ•¸æ“š")
                    continue

                # Step 2: è¨ˆç®—æŒ‡æ¨™
                context = self.market_data_service.analyze_technicals(df)
                
                # é˜²å‘†ï¼šå¦‚æœè¨ˆç®—å¤±æ•—å›å‚³ç©ºå­—å…¸ï¼Œç›´æ¥è·³é
                if not context:
                    print(f"   âš ï¸ è·³é {symbol}: æŠ€è¡“æŒ‡æ¨™è¨ˆç®—å¤±æ•— (å¯èƒ½æ•¸æ“šä¸è¶³)")
                    continue
                    
                context['symbol'] = symbol
                
                # Step 3: æª¢æŸ¥å€‰ä½
                current_position = self.executor.get_open_position(symbol)
                
                # Step 4: å‘¼å«å¤šç­–ç•¥æ•´åˆé‚è¼¯
                # ğŸ”¥ é€™è£¡æ¥æ”¶ 3 å€‹å›å‚³å€¼
                signal, reason, detailed_logs = self._get_combined_signal(df, context)
                
                close_price = context.get('close', 0.0)
                order_amount = config.ORDER_SIZES.get(symbol, config.ORDER_AMOUNT)

                # è§£æ ZigZag è³‡è¨Š (çµæ§‹)
                pivots = context.get('pivots', [])
                pivot_status = "ç„¡çµæ§‹"
                if pivots and len(pivots) > 0:
                    last_p = pivots[-1]
                    pivot_status = f"{last_p.get('type')}@{last_p.get('price'):.1f}"

                pos_status = current_position if current_position else "EMPTY"
                
                # ğŸ”¥ å„ªåŒ–é¡¯ç¤ºï¼šç¬¬ä¸€è¡Œé¡¯ç¤ºç¸½çµï¼Œä¸‹é¢åˆ—å‡ºæ‰€æœ‰ç­–ç•¥è©³æƒ…
                print(f"   [{symbol}] ${close_price:.2f} | ç¸½è¨Šè™Ÿ:{signal} | æŒå€‰:{pos_status} | çµæ§‹:{pivot_status}")
                for log in detailed_logs:
                    print(f"        ğŸ‘‰ {log}")

                # --- é€²å ´é‚è¼¯ ---
                if current_position is None:
                    if signal == "LONG":
                        self._execute_trade("buy", symbol, order_amount, close_price, reason, context)
                    elif signal == "SHORT":
                        self._execute_trade("sell", symbol, order_amount, close_price, reason, context)
                
                # --- å‡ºå ´é‚è¼¯ ---
                elif current_position == "LONG" and signal == "SHORT":
                    self._close_trade(symbol, close_price, "è¨Šè™Ÿåè½‰å¹³å¤š")
                
                elif current_position == "SHORT" and signal == "LONG":
                    self._close_trade(symbol, close_price, "è¨Šè™Ÿåè½‰å¹³ç©º")

            except Exception as e:
                print(f"   âŒ è™•ç† {symbol} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
                import traceback
                traceback.print_exc()

    def _execute_trade(self, side, symbol, amount, price, tag, context):
        """åŸ·è¡Œä¸‹å–®"""
        print(f"   ğŸš€ è§¸ç™¼ä¸‹å–®: {symbol} {side} ({tag})")
        order = self.executor.place_order(side, symbol, amount)
        
        if order or config.DRY_RUN:
            self.logger.log(side.upper(), price, amount, tag, symbol=symbol)
            if self.report_service and self.email_service:
                context['action'] = side.upper()
                context['price'] = price
                html_report = self.report_service.generate_entry_report(context)
                subject = f"ğŸš€ äº¤æ˜“å¿«è¨Š: {symbol} {side.upper()}"
                self.email_service.send_report(subject, html_report)

    def _close_trade(self, symbol, price, tag):
        """åŸ·è¡Œå¹³å€‰"""
        print(f"   ğŸ‘‹ è§¸ç™¼å¹³å€‰: {symbol} ({tag})")
        self.executor.close_position(symbol)
        self.logger.log("CLOSE", price, 0, tag, symbol=symbol)
--- END OF FILE: services\trading_service.py ---

--- START OF FILE: strategies\base_strategy.py ---
# strategies/base_strategy.py
from abc import ABC, abstractmethod
import pandas as pd

class BaseStrategy(ABC):
    @abstractmethod
    def analyze(self, df: pd.DataFrame, context: dict) -> dict:
        """
        æ‰€æœ‰ç­–ç•¥éƒ½å¿…é ˆå¯¦ä½œé€™å€‹æ–¹æ³•
        :param df: Kç·šè³‡æ–™
        :param context: å¸‚å ´æŒ‡æ¨™ (RSI, ZigZag ç­‰)
        :return: {
            "signal": "LONG" | "SHORT" | "NEUTRAL",
            "reason": "ç­–ç•¥è§¸ç™¼åŸå› ",
            "stop_loss": å»ºè­°æ­¢æåƒ¹,
            "take_profit": å»ºè­°æ­¢ç›ˆåƒ¹
        }
        """
        pass
--- END OF FILE: strategies\base_strategy.py ---

--- START OF FILE: strategies\harmonic_strategy.py ---
# strategies/harmonic_strategy.py
from .base_strategy import BaseStrategy
import math

class HarmonicStrategy(BaseStrategy):
    def __init__(self):
        # èª¤å·®å®¹å¿åº¦ (ä¾‹å¦‚ 0.1 ä»£è¡¨å…è¨± 10% çš„èª¤å·®)
        self.tolerance = 0.1

    def analyze(self, df, context) -> dict:
        """
        è«§æ³¢ç­–ç•¥ï¼šåˆ†æ ZigZag è½‰æŠ˜é»æ˜¯å¦ç¬¦åˆ Gartley ç­‰å‹æ…‹
        """
        # 1. å–å¾—ç”± MarketDataService ç®—å¥½çš„è½‰æŠ˜é»
        pivots = context.get('pivots', [])
        
        # è«§æ³¢å‹æ…‹è‡³å°‘éœ€è¦ 5 å€‹é» (X, A, B, C, D)
        if len(pivots) < 5:
            return {
                "signal": "NEUTRAL",
                "reason": "è½‰æŠ˜é»ä¸è¶³ (éœ€5é»)",
                "stop_loss": None,
                "take_profit": None
            }

        # 2. å–å‡ºæœ€è¿‘çš„ 5 å€‹é» (æ³¨æ„ï¼špivots åˆ—è¡¨æ˜¯ èˆŠ -> æ–°)
        # æˆ‘å€‘å®šç¾©: X(0), A(1), B(2), C(3), D(4) ç‚ºæœ€è¿‘çš„é» (Dæ˜¯æœ€æ–°åƒ¹æ ¼é™„è¿‘)
        # æ‰€ä»¥è¦å€’è‘—å–
        P_D = pivots[-1] # æœ€æ–°
        P_C = pivots[-2]
        P_B = pivots[-3]
        P_A = pivots[-4]
        P_X = pivots[-5] # æœ€èˆŠ

        # 3. å–å‡ºåƒ¹æ ¼èˆ‡æ–¹å‘
        price_X, type_X = P_X['price'], P_X['type']
        price_A, type_A = P_A['price'], P_A['type']
        price_B, type_B = P_B['price'], P_B['type']
        price_C, type_C = P_C['price'], P_C['type']
        # Dé»é€šå¸¸æ˜¯ã€Œç¾åœ¨åƒ¹æ ¼ã€æˆ–ã€Œå‰›å½¢æˆçš„è½‰æŠ˜ã€ï¼Œé€™è£¡å‡è¨­ D é»æ˜¯æœ€æ–°è½‰æŠ˜
        price_D, type_D = P_D['price'], P_D['type']

        signal = "NEUTRAL"
        reason = ""

        # ==========================================
        # 4. åˆ¤æ–·å‹æ…‹ï¼šBullish Gartley (çœ‹æ¼²)
        # çµæ§‹: X(ä½) -> A(é«˜) -> B(ä½) -> C(é«˜) -> D(ä½)
        # ==========================================
        if type_X == "LOW" and type_A == "HIGH" and type_B == "LOW" and type_C == "HIGH" and type_D == "LOW":
            
            # --- è¨ˆç®—æ–æ³¢é‚£å¥‘æ¯”ä¾‹ ---
            XA_len = abs(price_X - price_A)
            AB_len = abs(price_A - price_B)
            BC_len = abs(price_B - price_C)
            CD_len = abs(price_C - price_D)
            XD_len = abs(price_X - price_D)

            # Bé»å›æ’¤: AB / XA (Gartley æ¨™æº– 0.618)
            ratio_B = AB_len / XA_len
            
            # Dé»å›æ’¤: XD / XA (Gartley æ¨™æº– 0.786)
            ratio_D = XD_len / XA_len

            # æª¢æŸ¥èª¤å·® (Tolerance)
            is_B_valid = abs(ratio_B - 0.618) <= self.tolerance
            is_D_valid = abs(ratio_D - 0.786) <= self.tolerance
            
            if is_B_valid and is_D_valid:
                signal = "LONG"
                reason = f"Bullish Gartley (B={ratio_B:.2f}, D={ratio_D:.2f})"
                
                # å»ºè­°æ­¢æ: X é»ä¸‹æ–¹
                stop_loss = price_X * 0.995 
                # å»ºè­°æ­¢ç›ˆ: AD çš„ 0.618 å›èª¿è™•
                take_profit = price_D + (abs(price_A - price_D) * 0.618)
                
                return {
                    "signal": signal,
                    "reason": reason,
                    "stop_loss": stop_loss,
                    "take_profit": take_profit
                }

        # ==========================================
        # 5. åˆ¤æ–·å‹æ…‹ï¼šBearish Gartley (çœ‹è·Œ)
        # çµæ§‹: X(é«˜) -> A(ä½) -> B(é«˜) -> C(ä½) -> D(é«˜)
        # ==========================================
        elif type_X == "HIGH" and type_A == "LOW" and type_B == "HIGH" and type_C == "LOW" and type_D == "HIGH":
            
            XA_len = abs(price_X - price_A)
            AB_len = abs(price_A - price_B)
            XD_len = abs(price_X - price_D)

            ratio_B = AB_len / XA_len
            ratio_D = XD_len / XA_len

            is_B_valid = abs(ratio_B - 0.618) <= self.tolerance
            is_D_valid = abs(ratio_D - 0.786) <= self.tolerance
            
            if is_B_valid and is_D_valid:
                signal = "SHORT"
                reason = f"Bearish Gartley (B={ratio_B:.2f}, D={ratio_D:.2f})"
                
                # å»ºè­°æ­¢æ: X é»ä¸Šæ–¹
                stop_loss = price_X * 1.005
                take_profit = price_D - (abs(price_A - price_D) * 0.618)

                return {
                    "signal": signal,
                    "reason": reason,
                    "stop_loss": stop_loss,
                    "take_profit": take_profit
                }

        # è‹¥éƒ½ä¸ç¬¦åˆ
        return {
            "signal": "NEUTRAL",
            "reason": "æœªåµæ¸¬åˆ°è«§æ³¢å‹æ…‹",
            "stop_loss": None,
            "take_profit": None
        }
--- END OF FILE: strategies\harmonic_strategy.py ---

--- START OF FILE: strategies\ma_cross_strategy.py ---
# strategies/ma_cross_strategy.py
from .base_strategy import BaseStrategy

class MACrossStrategy(BaseStrategy):
    def analyze(self, df, context):
        # å¾ context å–å¾—å·²ç¶“ç®—å¥½çš„æŒ‡æ¨™ (ç”± MarketDataService æä¾›)
        # ğŸ”¥ ä¿®æ”¹ï¼šä½¿ç”¨ .get() çš„ç¬¬äºŒå€‹åƒæ•¸çµ¦äºˆé è¨­å€¼ï¼Œé˜²æ­¢ None
        trend = context.get('trend_signal', 'NEUTRAL') # LONG / SHORT
        ma_fast = context.get('ma_fast', 0.0)
        ma_slow = context.get('ma_slow', 0.0)
        
        # å†æ¬¡ç¢ºä¿å¦‚æœæ˜¯ None é‚„æ˜¯è¦è½‰æˆ float (é›™é‡ä¿éšª)
        if ma_fast is None: ma_fast = 0.0
        if ma_slow is None: ma_slow = 0.0

        signal = "NEUTRAL"
        reason = ""
        
        # ç°¡å–®çš„é»ƒé‡‘äº¤å‰/æ­»äº¡äº¤å‰é‚è¼¯
        if trend == "LONG":
            signal = "LONG"
            reason = f"MAé‡‘å‰ (Fast: {ma_fast:.2f} > Slow: {ma_slow:.2f})"
        elif trend == "SHORT":
            signal = "SHORT"
            reason = f"MAæ­»å‰ (Fast: {ma_fast:.2f} < Slow: {ma_slow:.2f})"
            
        return {
            "signal": signal,
            "reason": reason,
            "stop_loss": None,   # å¯åœ¨æ­¤åŠ å…¥ ATR æ­¢æé‚è¼¯
            "take_profit": None
        }
--- END OF FILE: strategies\ma_cross_strategy.py ---

--- START OF FILE: strategies\__init__.py ---
# strategies/__init__.py
from .base_strategy import BaseStrategy
from .ma_cross_strategy import MACrossStrategy
from .harmonic_strategy import HarmonicStrategy
# from .rsi_reversal_strategy import RsiReversalStrategy (å¦‚æœæœ‰çš„è©±)

# ğŸ”¥ å»ºç«‹ä¸€å€‹å°ç…§è¡¨ï¼Œæ–¹ä¾¿å­—ä¸²è½‰ç‰©ä»¶
STRATEGY_MAP = {
    "MACrossStrategy": MACrossStrategy,
    "HarmonicStrategy": HarmonicStrategy,
    # "RsiReversalStrategy": RsiReversalStrategy
}
--- END OF FILE: strategies\__init__.py ---

--- START OF FILE: test\run_tests.py ---
# tests/run_tests.py
import unittest
import sys
import os
import pandas as pd
import warnings

# å¿½ç•¥ FutureWarning è®“è¼¸å‡ºä¹¾æ·¨é»
warnings.simplefilter(action='ignore', category=FutureWarning)

# ğŸ”¥ è¨­å®šè·¯å¾‘ï¼šè®“æ¸¬è©¦è…³æœ¬èƒ½æ‰¾åˆ°ä¸Šä¸€å±¤çš„æ¨¡çµ„
current_dir = os.path.dirname(os.path.abspath(__file__))
project_root = os.path.dirname(current_dir)
sys.path.append(project_root)

# å¼•å…¥è¦æ¸¬è©¦çš„æ¨¡çµ„
import config
from utils.data_loader import BingXLoader
from services.market_data_service import MarketDataService
from strategies.ma_cross_strategy import MACrossStrategy
from strategies.harmonic_strategy import HarmonicStrategy
from utils.executor import BingXExecutor
import ccxt

class TestCryptoBot(unittest.TestCase):
    
    @classmethod
    def setUpClass(cls):
        """æ‰€æœ‰æ¸¬è©¦é–‹å§‹å‰åŸ·è¡Œä¸€æ¬¡ï¼Œå»ºç«‹å…±ç”¨ç‰©ä»¶"""
        print("\nğŸ¤– === é–‹å§‹ Crypto Bot å–®å…ƒæ¸¬è©¦ ===\n")
        cls.symbol = "ETH-USDT" # æ¸¬è©¦ç”¨å¹£ç¨®
        cls.timeframe = "15m"
        
        # 1. æ¸¬è©¦ Loader
        cls.loader = BingXLoader()
        
        # 2. æ¸¬è©¦ MarketDataService
        cls.market_service = MarketDataService()

    def test_01_data_loader(self):
        """æ¸¬è©¦ï¼šå¾äº¤æ˜“æ‰€æŠ“å– K ç·šæ•¸æ“š"""
        print("ğŸ§ª [1/5] æ¸¬è©¦ Data Loader...")
        df = self.loader.fetch_data(self.timeframe, self.symbol, limit=100)
        
        # é©—è­‰æ•¸æ“šæ˜¯å¦æ­£ç¢º
        self.assertIsNotNone(df, "æ•¸æ“šä¸æ‡‰ç‚º None")
        self.assertFalse(df.empty, "æ•¸æ“šä¸æ‡‰ç‚ºç©º")
        self.assertIn('close', df.columns, "å¿…é ˆåŒ…å« close æ¬„ä½")
        self.assertIn('volume', df.columns, "å¿…é ˆåŒ…å« volume æ¬„ä½")
        
        print(f"   âœ… æˆåŠŸç²å– {len(df)} ç­† K ç·šæ•¸æ“š")
        
        # å­˜èµ·ä¾†çµ¦å¾Œé¢çš„æ¸¬è©¦ç”¨ï¼Œé¿å…é‡è¤‡æ‰“ API
        TestCryptoBot.shared_df = df

    def test_02_market_data_calculation(self):
        """æ¸¬è©¦ï¼šè¨ˆç®—æŠ€è¡“æŒ‡æ¨™ (MA, RSI, ZigZag)"""
        print("ğŸ§ª [2/5] æ¸¬è©¦ æŠ€è¡“æŒ‡æ¨™è¨ˆç®—...")
        df = TestCryptoBot.shared_df
        
        context = self.market_service.analyze_technicals(df)
        
        # é©—è­‰é—œéµæŒ‡æ¨™æ˜¯å¦å­˜åœ¨
        self.assertIn('rsi', context, "ç¼ºå°‘ RSI")
        self.assertIn('ma_fast', context, "ç¼ºå°‘ MA Fast")
        self.assertIn('pivots', context, "ç¼ºå°‘ ZigZag Pivots")
        
        # é©—è­‰æ•¸å€¼æ˜¯å¦åˆç†
        rsi = context['rsi']
        self.assertTrue(0 <= rsi <= 100, f"RSI æ•¸å€¼ç•°å¸¸: {rsi}")
        
        pivots = context.get('pivots', [])
        print(f"   âœ… æŒ‡æ¨™è¨ˆç®—å®Œæˆ (RSI={rsi:.1f}, è½‰æŠ˜é»æ•¸={len(pivots)})")
        
        # å­˜èµ·ä¾†çµ¦ç­–ç•¥æ¸¬è©¦ç”¨
        TestCryptoBot.shared_context = context

    def test_03_zigzag_logic(self):
        """æ¸¬è©¦ï¼šZigZag è½‰æŠ˜é»é‚è¼¯"""
        print("ğŸ§ª [3/5] æ¸¬è©¦ ZigZag çµæ§‹...")
        pivots = TestCryptoBot.shared_context.get('pivots', [])
        
        if len(pivots) > 0:
            last_p = pivots[-1]
            self.assertIn('price', last_p)
            self.assertIn('type', last_p)
            self.assertIn(last_p['type'], ['HIGH', 'LOW'])
            print(f"   âœ… ZigZag æ ¼å¼æ­£ç¢º: {last_p['type']} @ {last_p['price']}")
        else:
            print("   âš ï¸ è­¦å‘Š: æ¨£æœ¬æ•¸æ“šéçŸ­ï¼ŒæœªæŠ“åˆ°è½‰æŠ˜é» (é€™åœ¨çŸ­ K ç·šä¸­å¯èƒ½ç™¼ç”Ÿ)")

    def test_04_strategies(self):
        """æ¸¬è©¦ï¼šç­–ç•¥åˆ†æé‚è¼¯ (MAäº¤å‰ & è«§æ³¢)"""
        print("ğŸ§ª [4/5] æ¸¬è©¦ ç­–ç•¥æ¨¡çµ„...")
        df = TestCryptoBot.shared_df
        context = TestCryptoBot.shared_context
        
        # A. æ¸¬è©¦ MA ç­–ç•¥
        ma_strategy = MACrossStrategy()
        res_ma = ma_strategy.analyze(df, context)
        self.assertIn(res_ma['signal'], ['LONG', 'SHORT', 'NEUTRAL'])
        print(f"   âœ… MAç­–ç•¥å›å‚³: {res_ma['signal']} ({res_ma['reason']})")
        
        # B. æ¸¬è©¦ è«§æ³¢ç­–ç•¥
        harmonic_strategy = HarmonicStrategy()
        res_har = harmonic_strategy.analyze(df, context)
        self.assertIn(res_har['signal'], ['LONG', 'SHORT', 'NEUTRAL'])
        print(f"   âœ… è«§æ³¢ç­–ç•¥å›å‚³: {res_har['signal']} ({res_har['reason']})")

    def test_05_executor_simulation(self):
        """æ¸¬è©¦ï¼šæ¨¡æ“¬ä¸‹å–®åŠŸèƒ½"""
        print("ğŸ§ª [5/5] æ¸¬è©¦ Executor (æ¨¡æ“¬æ¨¡å¼)...")
        
        # å¼·åˆ¶é–‹å•Ÿ DRY_RUN ä»¥å…çœŸçš„ä¸‹å–®
        original_dry_run = config.DRY_RUN
        config.DRY_RUN = True 
        
        executor = BingXExecutor(None) # å‚³å…¥ None å› ç‚ºæ¨¡æ“¬æ¨¡å¼ä¸éœ€è¦çœŸå¯¦ exchange ç‰©ä»¶
        
        # 1. æ¸¬è©¦ä¸‹å–®
        order = executor.place_order('buy', self.symbol, 0.01)
        self.assertIsNotNone(order, "ä¸‹å–®å›å‚³ä¸æ‡‰ç‚º None")
        
        # 2. æ¸¬è©¦æŸ¥è©¢å€‰ä½ (æ¨¡æ“¬è¨˜æ†¶é«”)
        pos = executor.get_open_position(self.symbol)
        self.assertEqual(pos, 'LONG', "æ¨¡æ“¬å€‰ä½æ‡‰è©²æ˜¯ LONG")
        
        # 3. æ¸¬è©¦å¹³å€‰
        executor.close_position(self.symbol)
        pos_after = executor.get_open_position(self.symbol)
        self.assertIsNone(pos_after, "å¹³å€‰å¾Œå€‰ä½æ‡‰ç‚º None")
        
        print("   âœ… æ¨¡æ“¬ä¸‹å–®/å¹³å€‰æµç¨‹é€šé")
        
        # é‚„åŸè¨­å®š
        config.DRY_RUN = original_dry_run

if __name__ == '__main__':
    unittest.main()
--- END OF FILE: test\run_tests.py ---

--- START OF FILE: utils\data_loader.py ---
import ccxt
import pandas as pd
import config
import time

class BingXLoader:
    def __init__(self):
        # åˆå§‹åŒ–äº¤æ˜“æ‰€ç‰©ä»¶
        self.exchange = ccxt.bingx({
            'enableRateLimit': True, # å•Ÿç”¨é€Ÿç‡é™åˆ¶ï¼Œé¿å…è¢«é– IP
        })

    def fetch_data(self, timeframe, symbol=None, limit=100):
        """
        å¾ BingX ç²å– K ç·šæ•¸æ“š
        :param timeframe: æ™‚æ¡† (ä¾‹å¦‚ '15m', '1h')
        :param symbol: äº¤æ˜“å° (ä¾‹å¦‚ 'BTC-USDT')ï¼Œå¦‚æœç‚º None å‰‡å˜—è©¦è®€å– config
        :param limit: ç²å– K ç·šçš„æ•¸é‡
        """
        # 1. è™•ç† Symbol (å„ªå…ˆä½¿ç”¨å‚³å…¥çš„åƒæ•¸ï¼Œå¦å‰‡ä½¿ç”¨ config é è¨­)
        if symbol is None:
            if hasattr(config, 'SYMBOL'):
                symbol = config.SYMBOL
            elif hasattr(config, 'COIN_LIST') and config.COIN_LIST:
                symbol = config.COIN_LIST[0]
            else:
                print("âŒ éŒ¯èª¤: æœªæŒ‡å®š Symbol ä¸” Config ä¸­æ‰¾ä¸åˆ°è¨­å®š")
                return None

        # CCXT é€šå¸¸éœ€è¦ 'BTC/USDT' æ ¼å¼ï¼Œè€Œæˆ‘å€‘ config å¯èƒ½å¯« 'BTC-USDT'
        formatted_symbol = symbol.replace('-', '/')

        try:
            # print(f"ğŸ“¥ æ­£åœ¨ç²å– {formatted_symbol} çš„ {timeframe} K ç·šæ•¸æ“š...")
            
            # 2. å‘¼å« CCXT API
            ohlcv = self.exchange.fetch_ohlcv(formatted_symbol, timeframe, limit=limit)
            
            if not ohlcv:
                print(f"âš ï¸ {symbol} ç²å–æ•¸æ“šç‚ºç©º")
                return None

            # 3. è½‰æ›ç‚º DataFrame
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # è™•ç†æ™‚é–“æˆ³ (è½‰ç‚ºäººé¡å¯è®€æ™‚é–“ï¼Œæ–¹ä¾¿é™¤éŒ¯)
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            
            # ç¢ºä¿æ•¸æ“šæ˜¯ float æ ¼å¼
            df = df.astype({
                'open': 'float',
                'high': 'float',
                'low': 'float',
                'close': 'float',
                'volume': 'float'
            })
            
            return df

        except Exception as e:
            print(f"âŒ {symbol} æ•¸æ“šç²å–å¤±æ•—: {e}")
            return None

# ç°¡å–®æ¸¬è©¦ç”¨
if __name__ == "__main__":
    loader = BingXLoader()
    # æ¸¬è©¦å¤šå¹£ç¨®å‚³åƒ
    df = loader.fetch_data(timeframe='15m', symbol='BTC-USDT')
    if df is not None:
        print(f"âœ… BTC-USDT æ¸¬è©¦æˆåŠŸ:\n{df.tail(2)}")
--- END OF FILE: utils\data_loader.py ---

--- START OF FILE: utils\executor.py ---
import ccxt
import config

class BingXExecutor:
    def __init__(self, exchange):
        self.exchange = exchange
        self.dry_run = config.DRY_RUN
        
        # æ¨¡æ“¬å€‰ä½å„²å­˜: {'BTC-USDT': 'LONG', ...}
        self.simulated_positions = {} 
        
        if not self.dry_run:
            print("âš™ï¸ [Executor] æ­£åœ¨ç‚ºç›£æ§æ¸…å–®è¨­å®šæ§“æ¡¿...")
            for symbol in config.COIN_LIST:
                self.set_leverage(config.LEVERAGE, symbol)

    def set_leverage(self, leverage, symbol):
        if self.dry_run: return 
        try:
            self.exchange.set_leverage(leverage, symbol)
        except Exception as e:
            print(f"âš ï¸ è¨­å®šæ§“æ¡¿å¤±æ•— ({symbol}): {e}")

    def get_open_position(self, symbol):
        """å›å‚³ 'LONG', 'SHORT' æˆ– None"""
        if self.dry_run:
            return self.simulated_positions.get(symbol)

        try:
            # é‡å°ç‰¹å®šå¹£ç¨®æŸ¥è©¢çœŸå¯¦å€‰ä½
            # æ³¨æ„: CCXT BingX fetch_positions å¯èƒ½éœ€è¦ symbol æ ¼å¼è½‰æ›
            positions = self.exchange.fetch_positions([symbol.replace('-', '/')])
            for pos in positions:
                # æª¢æŸ¥åˆç´„æ•¸é‡ > 0
                if float(pos['contracts']) > 0:
                    return pos['side'].upper() # LONG / SHORT
            return None
        except Exception as e:
            print(f"âš ï¸ è®€å–å€‰ä½å¤±æ•— ({symbol}): {e}")
            return None

    def place_order(self, side, symbol, amount):
        if self.dry_run:
            print(f"ğŸ§ª [æ¨¡æ“¬] {symbol} ä¸‹å–®: {side.upper()} {amount}")
            # æ›´æ–°æ¨¡æ“¬ç‹€æ…‹
            pos_type = 'LONG' if side == 'buy' else 'SHORT'
            self.simulated_positions[symbol] = pos_type
            return {'id': 'sim_order_id'}

        try:
            print(f"âš¡ [çœŸå¯¦] {symbol} ä¸‹å–®: {side.upper()} {amount} ...")
            order = self.exchange.create_market_order(symbol.replace('-', '/'), side, amount)
            print(f"âœ… ä¸‹å–®æˆåŠŸ! ID: {order['id']}")
            return order
        except Exception as e:
            print(f"âŒ ä¸‹å–®å¤±æ•— ({symbol}): {e}")
            return None
        
    def close_position(self, symbol):
        if self.dry_run:
            if self.simulated_positions.get(symbol):
                print(f"ğŸ§ª [æ¨¡æ“¬] {symbol} å¹³å€‰æˆåŠŸ")
                self.simulated_positions[symbol] = None
            return

        try:
            # çœŸå¯¦å¹³å€‰ï¼šé€šå¸¸ä½¿ç”¨ reduceOnly æˆ–æŸ¥è©¢ç•¶å‰æŒå€‰é‡å¾Œåå‘æ“ä½œ
            # é€™è£¡ç°¡å–®ç¤ºç¯„ï¼šå…ˆæŸ¥æ–¹å‘ï¼Œå†åå‘å¸‚åƒ¹å…¨å¹³
            current_pos = self.get_open_position(symbol)
            if not current_pos:
                return

            side = 'sell' if current_pos == 'LONG' else 'buy'
            # æ³¨æ„ï¼šBingX å¹³å€‰æœ€å¥½å‚³å…¥ reduceOnly: True
            # Amount é€™è£¡æš«æ™‚ç”¨ config çš„è¨­å®šï¼Œç†æƒ³æƒ…æ³æ˜¯è®€å–ç•¶å‰æŒå€‰æ•¸é‡
            amount = config.ORDER_SIZES.get(symbol, config.ORDER_AMOUNT)

            print(f"âš¡ [çœŸå¯¦] {symbol} å¹³å€‰: {side.upper()} ...")
            self.exchange.create_market_order(
                symbol.replace('-', '/'), 
                side, 
                amount, 
                params={'reduceOnly': True} 
            )
            print(f"âœ… {symbol} å¹³å€‰æŒ‡ä»¤å·²ç™¼é€")
            
        except Exception as e:
            print(f"âŒ å¹³å€‰å¤±æ•— ({symbol}): {e}")
--- END OF FILE: utils\executor.py ---

--- START OF FILE: utils\trade_logger.py ---
import json
import os
from datetime import datetime
import config

class TradeLogger:
    def __init__(self, filename="logs/trade_history.json"):
        self.filename = filename
        
        # ç¢ºä¿ log ç›®éŒ„å­˜åœ¨
        log_dir = os.path.dirname(self.filename)
        if log_dir and not os.path.exists(log_dir):
            os.makedirs(log_dir, exist_ok=True)

    def log(self, action, price, amount, tag, pnl=0.0, balance=0.0, symbol=None):
        """
        è¨˜éŒ„äº¤æ˜“åˆ° JSON æª”æ¡ˆ
        :param symbol: äº¤æ˜“å¹£ç¨® (ä¾‹å¦‚ 'BTC-USDT') ğŸ”¥ æ–°å¢é€™å€‹åƒæ•¸
        """
        
        # å¦‚æœå‘¼å«æ™‚æ²’å‚³ symbolï¼Œå˜—è©¦ç”¨ config è£¡çš„é è¨­å€¼ (å…¼å®¹èˆŠç¨‹å¼ç¢¼)
        if symbol is None:
            if hasattr(config, 'SYMBOL'):
                symbol = config.SYMBOL
            elif hasattr(config, 'COIN_LIST') and config.COIN_LIST:
                symbol = config.COIN_LIST[0]
            else:
                symbol = "UNKNOWN"

        record = {
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "symbol": symbol,  # ğŸ”¥ å¯«å…¥å¹£ç¨®
            "action": action,
            "price": float(price),
            "amount": float(amount),
            "tag": tag,
            "realized_pnl": float(pnl),
            "balance": float(balance)
        }

        # è®€å–ç¾æœ‰ç´€éŒ„
        history = []
        if os.path.exists(self.filename):
            try:
                with open(self.filename, "r", encoding="utf-8") as f:
                    history = json.load(f)
            except Exception:
                history = []

        # åŠ å…¥æ–°ç´€éŒ„
        history.append(record)

        # å¯«å›æª”æ¡ˆ
        try:
            with open(self.filename, "w", encoding="utf-8") as f:
                json.dump(history, f, indent=4, ensure_ascii=False)
            print(f"ğŸ“ [Log] {symbol} äº¤æ˜“ç´€éŒ„å·²æ›´æ–°: {action} @ {price}")
        except Exception as e:
            print(f"âŒ [Log] å¯«å…¥å¤±æ•—: {e}")

# æ¸¬è©¦ç”¨
if __name__ == "__main__":
    logger = TradeLogger()
    logger.log("TEST_ENTRY", 50000, 0.001, "æ¸¬è©¦å¯«å…¥", symbol="BTC-USDT")
--- END OF FILE: utils\trade_logger.py ---

--- START OF FILE: utils\zigzag.py ---
import numpy as np
import pandas as pd
from scipy.signal import argrelextrema

class ZigZagIdentifier:
    def __init__(self, order: int = 5):
        self.order = order

    def find_pivots(self, df: pd.DataFrame) -> dict:
        if df is None or df.empty: return {}
        highs = df['high'].values
        lows = df['low'].values
        timestamps = df.index.values

        high_idx = argrelextrema(highs, np.greater, order=self.order)[0]
        low_idx = argrelextrema(lows, np.less, order=self.order)[0]
        
        high_points = [{'index': int(i), 'price': float(highs[i]), 'type': 'HIGH', 'time': str(timestamps[i])} for i in high_idx]
        low_points = [{'index': int(i), 'price': float(lows[i]), 'type': 'LOW', 'time': str(timestamps[i])} for i in low_idx]
            
        return {'highs': high_points, 'lows': low_points}
    
    def get_last_n_pivots(self, df: pd.DataFrame, n: int = 5) -> list:
        pivots = self.find_pivots(df)
        if not pivots: return []
        all_pivots = pivots['highs'] + pivots['lows']
        all_pivots.sort(key=lambda x: x['index'])
        return all_pivots[-n:]
--- END OF FILE: utils\zigzag.py ---
